<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Rails 中文入门教程</title>
        <description>Rails 中文入门教程 - Name Lastname</description>
        <link>http://tutorial.railschina.org</link>
        <link>http://tutorial.railschina.org</link>
        <lastBuildDate>2013-08-29T10:16:31+08:00</lastBuildDate>
        <pubDate>2013-08-29T10:16:31+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>第七章 登录</title>
                <description>&lt;h1&gt;第七章  登录&lt;/h1&gt;

&lt;p&gt;现在我们已经有了可用的用户模块，现在是时候添加大多数网站必备的功能了：让用户能够登录网站。在7.2小节，我们将用HTML&lt;em&gt;表格&lt;/em&gt;将用户登录信息提交给我们的应用。然后，在7.4小节，我们会创建一个用户并将其属性保存在数据库中。用户登录后，用新建的用户信息生成用户主页非常重要，所以我们会创建一个显示用户信息的页面。这是实现用户REST架构的第一步（2.2.2小节）。和平常一样，我们会一边开发一边测试，用RSpec和Capybara简洁的完成集成测试，并扩展本章的主题。&lt;/p&gt;

&lt;p&gt;为了生成用户主页，我们需要数据库中的用户数据。这产生了鸡生蛋，蛋生鸡的问题：网站如何在没有可工作的登录页面时创建用户？幸运的是，这个问题已被解决。在6.3.5小节，我们用Rails控制台创建了一个用户记录。如果你跳过了那个小节，你最好在继续之前完成6.3.5小节。&lt;/p&gt;

&lt;p&gt;如果你跟随本教程使用版本控制，那么就像平常一样创建一个分支：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git checkout master
$ git checkout -b sign-up
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;7.1 显示用户&lt;/h2&gt;
</description>
                <link>http://tutorial.railschina.org/rails%20%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B/2013/08/29/chapter-7</link>
                <guid>http://tutorial.railschina.org/rails%20%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B/2013/08/29/chapter-7</guid>
                <pubDate>2013-08-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Chapter 6</title>
                <description>&lt;h1&gt;第七章  登录&lt;/h1&gt;

&lt;p&gt;现在我们已经有了可用的用户模块，现在是时候添加大多数网站必备的功能了：让用户能够登录网站。在7.2小节，我们将用HTML&lt;em&gt;表格&lt;/em&gt;将用户登录信息提交给我们的应用。然后，在7.4小节，我们会创建一个用户并将其属性保存在数据库中。用户登录后，用新建的用户信息生成用户主页非常重要，所以我们会创建一个显示用户信息的页面。这是实现用户REST架构的第一步（2.2.2小节）。和平常一样，我们会一边开发一边测试，用RSpec和Capybara简洁的完成集成测试，并扩展本章的主题。&lt;/p&gt;

&lt;p&gt;为了生成用户主页，我们需要数据库中的用户数据。这产生了鸡生蛋，蛋生鸡的问题：网站如何在没有可工作的登录页面时创建用户？幸运的是，这个问题已被解决。在6.3.5小节，我们用Rails控制台创建了一个用户记录。如果你跳过了那个小节，你最好在继续之前完成6.3.5小节。&lt;/p&gt;

&lt;p&gt;如果你跟随本教程使用版本控制，那么就像平常一样创建一个分支：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git checkout master
$ git checkout -b sign-up
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;7.1 显示用户&lt;/h2&gt;
</description>
                <link>http://tutorial.railschina.org/2013/08/28/chapter-6</link>
                <guid>http://tutorial.railschina.org/2013/08/28/chapter-6</guid>
                <pubDate>2013-08-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>第五章 结构布局</title>
                <description>&lt;h1&gt;&lt;a href=&quot;filling-in-the-layout#top&quot;&gt;第五章 布局&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;经过简单的第四章 Ruby 语言的学习之后,我们掌握了在程序中引入布局文件的技巧，但是目前这个布局文件还是空的。在这一章节，我们将要通过使用 &lt;em&gt;Bootstrap&lt;/em&gt; 框架来对自定义我们的网页布局。我们还要构建出网站中所需要元素和链接，而在这期间，我们将会学会 partial, routes , 和asset pipeline ,同时还会介绍 Sass。
我们同时还要运用最新的Rspec技术重构第三章的测试.在本章的最后，我们将会实现第一个重要功能：用户注册.&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;filling-in-the-layout#sec-structure&quot;&gt;5.1 布局结构&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Rails Tutorial&lt;/em&gt; 是一本关于WEB开发的书，并非WEB设计，但是如果一整个应用程序之中都没有网页的设计将会让我们的成果显得很烂，也会让自己觉得很失败。所以我们在这一章节我们需要用上一点点的CSS技术，为了让我们能更轻松地上手使用CSS进行Web设计开发，我们使用了&lt;a href=&quot;http://twitter.github.com/bootstrap/&quot;&gt;Bootstrap&lt;/a&gt;,一个又Twitter开源的web设计框架我们将会给我们的代码加上一些不同的风格，我们还要用上 partials 来然我们的布局代码显得更加简洁紧凑。&lt;/p&gt;

&lt;p&gt;一般来说，当你开发web应用的时候，如果事先越早从较高的层次上想好自己要写的应用越好。所以在剩下的书中，我们将会使用 &lt;em&gt;mockups&lt;/em&gt; (和 &lt;em&gt;wireframes&lt;/em&gt; 差不多，就是网络线框图 ), 的方法对应用进行开发。在这一章，我们主要将开发我们在 3.1 中说过的静态页面，包括网站logo，导航栏，和网站的页脚。于是我们事先已经对我们的作品作出一个 mockup 设计：
&lt;a href=&quot;filling-in-the-layout#fig-home_page_mockup&quot;&gt;Figure 5.1&lt;/a&gt;.你可以在这里看到最终结果&lt;a href=&quot;filling-in-the-layout#fig-site_with_footer&quot;&gt;Figure 5.7&lt;/a&gt;.你或许会发现他们之间有着一些细节的差别--例如我们在最后加上了Rails的logo，但是没关系，Mockup 不需要太精确。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/figures/home_page_mockup_bootstrap.png&quot; alt=&quot;home\_page\_mockup\_bootstrap&quot;&gt;&lt;/p&gt;

&lt;p&gt;Figure 5.1: A mockup of the sample application’s Home page. &lt;a href=&quot;http://railstutorial.org/images/figures/home_page_mockup_bootstrap-full.png&quot;&gt;(full
size)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;和平常一样，如果你使用了Git作为版本管理工具那么现在是时候开始再建立一个新的分支了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git checkout -b filling-in-layout
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;filling-in-the-layout#sec-adding_to_the_layout&quot;&gt;5.1.1 Site navigation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;和我们在示例应用中做过的一样，我们先要更改网站的模板文件 &lt;code&gt;application.html.erb&lt;/code&gt;，其中包含了你的 HTML 文件的大体框架。还有你的CSS和JS文件。全文如下：&lt;/p&gt;

&lt;p&gt;Listing 5.1. The site layout with added structure. \
&lt;code&gt;app/views/layouts/application.html.erb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;%= full_title(yield(:title)) %&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;%= stylesheet_link_tag    &amp;quot;application&amp;quot;, media: &amp;quot;all&amp;quot; %&amp;gt;
    &amp;lt;%= javascript_include_tag &amp;quot;application&amp;quot; %&amp;gt;
    &amp;lt;%= csrf_meta_tags %&amp;gt;
    &amp;lt;!--[if lt IE 9]&amp;gt;
    &amp;lt;script src=&amp;quot;http://html5shim.googlecode.com/svn/trunk/html5.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;![endif]--&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;header class=&amp;quot;navbar navbar-fixed-top navbar-inverse&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;navbar-inner&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
          &amp;lt;%= link_to &amp;quot;sample app&amp;quot;, &amp;#39;#&amp;#39;, id: &amp;quot;logo&amp;quot; %&amp;gt;
          &amp;lt;nav&amp;gt;
            &amp;lt;ul class=&amp;quot;nav pull-right&amp;quot;&amp;gt;
              &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Home&amp;quot;,    &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
              &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Help&amp;quot;,    &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
              &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Sign in&amp;quot;, &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
          &amp;lt;/nav&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/header&amp;gt;
    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
      &amp;lt;%= yield %&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里要注意，我们用的哈希是Ruby-1.9的形式。&lt;/p&gt;

&lt;p&gt;例如在这里：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;%= stylesheet_link_tag &amp;quot;application&amp;quot;, :media =&amp;gt; &amp;quot;all&amp;quot; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;被替换成了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;%= stylesheet_link_tag &amp;quot;application&amp;quot;, media: &amp;quot;all&amp;quot; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为旧的哈希形式在Ruby on Rails 社区之中依然十分流行，所以认得这两种形式的哈希写法还是必须的。&lt;/p&gt;

&lt;p&gt;现在我们再来看看文件中的其他元素。Rails 3 默认使用了HTML5 （文档开头需要标注 &lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/code&gt;）；然而 HTML5 标准相对较新，有的浏览器并未全面支持（例如IE），因此我们加入一些 JavaScript 代码来作为解决方案：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;!--[if lt IE 9]&amp;gt;
&amp;lt;script src=&amp;quot;http://html5shim.googlecode.com/svn/trunk/html5.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;![endif]--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里用上了一个奇怪的语句：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;!--[if lt IE 9]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该语句表明在关闭符号线以内的语句将在浏览器 Microsoft Internet Explorer (IE) 低于 9 (&lt;code&gt;if lt IE 9&lt;/code&gt;)的时候执行。其中怪怪的语句  &lt;code&gt;[if lt IE 9]&lt;/code&gt; 并不是 Rails 的一部分，它是IE浏览器支持的语法，具体看这里&lt;a href=&quot;http://en.wikipedia.org/wiki/Conditional_comment&quot;&gt;conditional comment&lt;/a&gt; 。这样一来，就保证了我们只会在IE浏览器的版本低于9的时候加载我们需要的脚本文件。&lt;/p&gt;

&lt;p&gt;下一部分是网站的头部，包含了 logo ，还有一些用来封装内容的 div 标签，还有一个 list 元素作为导航链接页面。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;header class=&amp;quot;navbar navbar-fixed-top navbar-inverse&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;navbar-inner&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
      &amp;lt;%= link_to &amp;quot;sample app&amp;quot;, &amp;#39;#&amp;#39;, id: &amp;quot;logo&amp;quot; %&amp;gt;
      &amp;lt;nav&amp;gt;
        &amp;lt;ul class=&amp;quot;nav pull-right&amp;quot;&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Home&amp;quot;,    &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Help&amp;quot;,    &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Sign in&amp;quot;, &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/nav&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/header&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的 &lt;code&gt;header&lt;/code&gt; 标签指出了标签内部的元素应该位于页面的顶端。我们在  &lt;code&gt;header&lt;/code&gt; 标签上标明了三个 CSS Class 分别为  &lt;code&gt;navbar&lt;/code&gt;, &lt;code&gt;navbar-fixed-top&lt;/code&gt;, and
&lt;code&gt;navbar-inverse&lt;/code&gt; ，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;header class=&amp;quot;navbar navbar-fixed-top navbar-inverse&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有的HTML元素都可以分配一个 id 或者多个 class，这在CSS布局中是极为常用的技巧。这三个类名是实现封装在Bootstrap前端框架中的，我们将实现在&lt;a href=&quot;filling-in-the-layout#sec-custom_css&quot;&gt;Section 5.1.2&lt;/a&gt;中.&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;header&lt;/code&gt; 标签中，我们看到两个 div 标签：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;div class=&amp;quot;navbar-inner&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;div 标签就是一个常见的分割符，它对于文档不做任何事实上的分割作用。在HTML5出现之前，几乎所有的网站的布局分割都需要div标签，现在，我们可以运用HTML5技术加入 &lt;code&gt;header&lt;/code&gt;,
&lt;code&gt;nav&lt;/code&gt;, 和 &lt;code&gt;section&lt;/code&gt; 元素用来更为明确地对网页文档进行分割布局。在这里，我们也为了每一个div加上了class属性，这里每一个class属性都在Bootstrap中有着特殊的意义。&lt;/p&gt;

&lt;p&gt;看完了div，接着就是数行内嵌的Ruby代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;%= link_to &amp;quot;sample app&amp;quot;, &amp;#39;#&amp;#39;, id: &amp;quot;logo&amp;quot; %&amp;gt;
&amp;lt;nav&amp;gt;
  &amp;lt;ul class=&amp;quot;nav pull-right&amp;quot;&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Home&amp;quot;,    &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Help&amp;quot;,    &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Sign in&amp;quot;, &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/nav&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用了 Rails helper  &lt;code&gt;link_to&lt;/code&gt;  来创建链接(我们曾经使用 &lt;code&gt;a&lt;/code&gt; 元素来创建链接).&lt;code&gt;link_to&lt;/code&gt;的第一个参数是链接的文本，而第二个是URI。我们暂时在链接的目标URI都先填上了固定链接 ‘#’ ，这在网页设计中十分常见。第三个参数，我们填上了一个id为logo的哈希。Rails helper 用这样的方式来给用户提供更加便捷的HTML选项。&lt;/p&gt;

&lt;p&gt;第二个div包含的元素是一个导航链接产生的list，通过 “无顺序清单” &lt;code&gt;ul&lt;/code&gt; 标签和 &lt;code&gt;list&lt;/code&gt; 标签 &lt;code&gt;li&lt;/code&gt; 的运用即可达到效果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;nav&amp;gt;
  &amp;lt;ul class=&amp;quot;nav pull-right&amp;quot;&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Home&amp;quot;,    &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Help&amp;quot;,    &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Sign in&amp;quot;, &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/nav&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，虽然 &lt;code&gt;nav&lt;/code&gt; 标签好似优点多余，但是表明了块内的代码作用，并且在这里，&lt;code&gt;nav&lt;/code&gt; 和 &lt;code&gt;pull-right&lt;/code&gt; class 在 &lt;code&gt;Bootstrap&lt;/code&gt; 中存在特殊含义。当经过Rails处理了内嵌的Ruby代码之后，这样的列表就会变成这样:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;nav&amp;gt;
  &amp;lt;ul class=&amp;quot;nav pull-right&amp;quot;&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Home&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Help&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Sign in&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/nav&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在整个布局文件的末尾才是主要内容的 &lt;code&gt;div&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
  &amp;lt;%= yield %&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样，&lt;code&gt;container&lt;/code&gt; 也在Bootstrap中有着特殊意义。我们曾经在 3.3.4 中学过了 &lt;code&gt;yield&lt;/code&gt; 方法可以将内容页插入布局页。页脚我们将会在 5.1.3 中加入，我们的布局页面暂时已经完成，我们已经可以通过访问首页来对其进行访问了。要想用上这个布局文件，我们还需要在 &lt;code&gt;home.html.erb&lt;/code&gt; 页面之中插入一些元素：&lt;/p&gt;

&lt;p&gt;Listing 5.2. The Home page with a link to the signup page. \
&lt;code&gt;app/views/static_pages/home.html.erb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;div class=&amp;quot;center hero-unit&amp;quot;&amp;gt;
  &amp;lt;h1&amp;gt;Welcome to the Sample App&amp;lt;/h1&amp;gt;

  &amp;lt;h2&amp;gt;
    This is the home page for the
    &amp;lt;a href=&amp;quot;http://railstutorial.org/&amp;quot;&amp;gt;Ruby on Rails Tutorial&amp;lt;/a&amp;gt;
    sample application.
  &amp;lt;/h2&amp;gt;

  &amp;lt;%= link_to &amp;quot;Sign up now!&amp;quot;, &amp;#39;#&amp;#39;, class: &amp;quot;btn btn-large btn-primary&amp;quot; %&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;%= link_to image_tag(&amp;quot;rails.png&amp;quot;, alt: &amp;quot;Rails&amp;quot;), &amp;#39;http://rubyonrails.org/&amp;#39; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在这里就为第七章的用户系统做好准备，第一个 &lt;code&gt;link_to&lt;/code&gt; 建立了一个固定链接。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;a href=&amp;quot;#&amp;quot; class=&amp;quot;btn btn-large btn-primary&amp;quot;&amp;gt;Sign up now!&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，div标签中的 &lt;code&gt;hero-unit&lt;/code&gt; 在Bootstrap中有着特殊意义的，同理对于注册按钮中的 &lt;code&gt;btn&lt;/code&gt;, &lt;code&gt;btn-large&lt;/code&gt;, 和 &lt;code&gt;btn-primary&lt;/code&gt; 类名。&lt;/p&gt;

&lt;p&gt;第二个  &lt;code&gt;link_to&lt;/code&gt; 中见加上了 &lt;code&gt;image_tag&lt;/code&gt; helper函数，它接受的参数为图片的路径和一个可选的哈希，在这里，我们把图片链接的  &lt;code&gt;alt&lt;/code&gt;  属性通过符号进行了设置，它能产生出这样的HTML代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;img alt=&amp;quot;Rails&amp;quot; src=&amp;quot;/assets/rails.png&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;alt&lt;/code&gt; 属性的值将会当在图片不存在的时候显示，它是一种当图片无法显示时对读者补偿机制。由于人们常常漏过图片的 alt 属性，Rails 在你使用了 image_tag 函数的时候默认把图片的文件名作为其 alt 属性。在这个例子里，我们把 alt 文字值指定为 “Rails”。&lt;/p&gt;

&lt;p&gt;现在，我们终于可以看到我们辛苦劳动的果实。很酷，不是么？(&lt;a href=&quot;filling-in-the-layout#fig-layout_no_logo_or_custom_css&quot;&gt;Figure 5.2&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;另外，你可能会很惊讶地发现首页上 &lt;code&gt;rails.png&lt;/code&gt; 竟然确实存在。它在哪里？事实上，每一个新建的Rails应用都可以在 &lt;code&gt;app/assets/images/rails.png&lt;/code&gt; 找到一张Rails的标志。因为我们实用了 &lt;code&gt;image_tag&lt;/code&gt; Helper , Rails 将会通过 asset pipeline 技术自动链接到正确地地址(&lt;a href=&quot;filling-in-the-layout#sec-sass_and_the_asset_pipeline&quot;&gt;Section 5.2&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/figures/layout_no_logo_or_custom_css_bootstrap.png&quot; alt=&quot;layout\_no\_logo\_or\_custom\_css\_bootstrap&quot;&gt;&lt;/p&gt;

&lt;p&gt;Figure 5.2: The Home page
(&lt;a href=&quot;http://localhost:3000/static_pages/home&quot;&gt;/static_pages/home&lt;/a&gt;) with no
custom CSS. &lt;a href=&quot;http://railstutorial.org/images/figures/layout_no_logo_or_custom_css_bootstrap-full.png&quot;&gt;(full
size)&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;filling-in-the-layout#sec-custom_css&quot;&gt;5.1.2 Bootstrap 自定义 CSS&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在 &lt;a href=&quot;filling-in-the-layout#sec-adding_to_the_layout&quot;&gt;Section 5.1.1&lt;/a&gt;中，我们将许多HTML元素设置了class，它让我们便捷地产生许多CSS效果。事实上，其中绝大多数的效果来自于&lt;a href=&quot;http://twitter.github.com/bootstrap/&quot;&gt;Bootstrap&lt;/a&gt;,一个来自Twitter的网页框架，它使我们能够更加便捷地添加交互与设计网页。在这一章里，我们将会把 Bootstrap 和一些自定义CSS规则结合起来，制作自己的网站应用。&lt;/p&gt;

&lt;p&gt;我们首先要添加 Bootstrap,它在 Rails 应用中已经被编译成了  &lt;code&gt;bootstrap-sass&lt;/code&gt; 我们可以在这里看到&lt;a href=&quot;filling-in-the-layout#code-bootstrap_sass&quot;&gt;Listing 5.3&lt;/a&gt;.Bootstrap 框架最初实用的是 &lt;a href=&quot;http://lesscss.org/&quot;&gt;LESS CSS&lt;/a&gt; 语言，它是一种构建动态样式表的语言。然而，Rails 的 asset pipeline 支持的是另一种(很类似)的语言 Sass，(&lt;a href=&quot;filling-in-the-layout#sec-sass_and_the_asset_pipeline&quot;&gt;Section 5.2&lt;/a&gt;)。所以我们添加的是 &lt;code&gt;bootstrap-sass&lt;/code&gt; 的gem ，它已经Bootstrap从LESS语言转换为SASS语言，让他能够被应用正常实用。&lt;/p&gt;

&lt;p&gt;Listing 5.3. Adding the &lt;code&gt;bootstrap-sass&lt;/code&gt; gem to the &lt;code&gt;Gemfile&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;source &amp;#39;https://rubygems.org&amp;#39;

gem &amp;#39;rails&amp;#39;, &amp;#39;3.2.9&amp;#39;
gem &amp;#39;bootstrap-sass&amp;#39;, &amp;#39;2.1&amp;#39;
.
.
.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们运行&lt;code&gt;bundle install&lt;/code&gt; 安装 Bootstrap：    &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后我们要重启网页服务器，一次来保证新加入的插件正常工作。(在大部分系统上，重启服务器只需要按 &lt;code&gt;Ctrl-C&lt;/code&gt; 之后重新运行&lt;code&gt;rails server&lt;/code&gt;. )&lt;/p&gt;

&lt;p&gt;要加入自定义CSS到应用程序中就是要创建一个文件包含：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;app/assets/stylesheets/custom.css.scss
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，目录和文件的名字都被加上了。目录：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;app/assets/stylesheets
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是 asset pipeline的一部分，而在该目录下的任何一部分都会被包含在文件  &lt;code&gt;application.css&lt;/code&gt; 中作为网站的布局。另外，文件 &lt;code&gt;custom.css.scss&lt;/code&gt; 的名字中包含 &lt;code&gt;.css&lt;/code&gt; 后缀，说明了它是一个 CSS 文件，而 &lt;code&gt;.scss&lt;/code&gt; 后缀，说明了它是 “Sassy CSS” 文件以便 asset pipeline 实用 Sass 处理该文件。&lt;/p&gt;

&lt;p&gt;建立了自定义CSS文件之后，我们可以使用 &lt;code&gt;@import&lt;/code&gt; 函数来加入 Bootstrap 如下：&lt;/p&gt;

&lt;p&gt;Listing 5.4. Adding Bootstrap CSS. \
&lt;code&gt;app/assets/stylesheets/custom.css.scss&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;@import &amp;quot;bootstrap&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;折一行，包含了整个Bootstrap 的 CSS 框架，结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/figures/sample_app_only_bootstrap.png&quot; alt=&quot;sample\_app\_only\_bootstrap&quot;&gt;&lt;/p&gt;

&lt;p&gt;Figure 5.3: The sample application with Bootstrap CSS. &lt;a href=&quot;http://railstutorial.org/images/figures/sample_app_only_bootstrap-full.png&quot;&gt;(full
size)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后我们将要添加一些全站共用的CSS代码到布局文件中去。为了让自己写的代码更加清晰易懂，我们常常实用CSS注释，即在 &lt;code&gt;/* … */&lt;/code&gt; 中加入注释文字。&lt;/p&gt;

&lt;p&gt;Listing 5.5. Adding CSS for some universal styling applying to all
pages. \
&lt;code&gt;app/assets/stylesheets/custom.css.scss&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;@import &amp;quot;bootstrap&amp;quot;;

/* universal */

html {
  overflow-y: scroll;
}

body {
  padding-top: 60px;
}

section {
  overflow: auto;
}

textarea {
  resize: vertical;
}

.center {
  text-align: center;
}

.center h1 {
  margin-bottom: 10px;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/images/figures/sample_app_universal.png&quot; alt=&quot;sample\_app\_universal&quot;&gt;&lt;/p&gt;

&lt;p&gt;Figure 5.4: Adding some spacing and other universal styling. &lt;a href=&quot;http://railstutorial.org/images/figures/sample_app_universal-full.png&quot;&gt;(full
size)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意&lt;a href=&quot;filling-in-the-layout#code-universal_css&quot;&gt;Listing 5.5&lt;/a&gt; 中展示了一个相对固定的格式。通常来说，CSS 规则由一个class 或 id 或 html tag 或多种的组合，接着一行或者数行的样式命令，例如：&lt;/p&gt;

&lt;p&gt;body {
      padding-top: 60px;
    }&lt;/p&gt;

&lt;p&gt;它将设置60像素的顶部间隔长。因为 &lt;code&gt;navbar-fixed-top&lt;/code&gt; 类处于  &lt;code&gt;header&lt;/code&gt; tag之中，Bootstrap 将导航栏置于页面顶端，为了和正文保持距离，所以设置了正文的顶端间隔。&lt;/p&gt;

&lt;p&gt;此外，CSS中的这条规则&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;.center {
  text-align: center;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同理，在这里 把 &lt;code&gt;center&lt;/code&gt; 类绑定了 &lt;code&gt;text-align: center&lt;/code&gt; 属性。在这里，&lt;code&gt;.center&lt;/code&gt; 中的 &lt;code&gt;.&lt;/code&gt;  表示匹配的是类对象(而井号 &lt;code&gt;#&lt;/code&gt; 表示匹配的是 id )。这条意味着包含了&lt;code&gt;center&lt;/code&gt; 类的元素将会被在置于页面的中央。 &lt;/p&gt;

&lt;p&gt;虽然通过 Bootsrtap 的 CSS 规则能够获得很漂亮的排版，但是我们还是要加入一些自定义规则来运用在网站和页面的布局上。&lt;/p&gt;

&lt;p&gt;Listing 5.6. Adding CSS for nice typography. \
&lt;code&gt;app/assets/stylesheets/custom.css.scss&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;@import &amp;quot;bootstrap&amp;quot;;
.
.
.

/* typography */

h1, h2, h3, h4, h5, h6 {
  line-height: 1;
}

h1 {
  font-size: 3em;
  letter-spacing: -2px;
  margin-bottom: 30px;
  text-align: center;
}

h2 {
  font-size: 1.7em;
  letter-spacing: -1px;
  margin-bottom: 30px;
  text-align: center;
  font-weight: normal;
  color: #999;
}

p {
  font-size: 1.1em;
  line-height: 1.7em;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/images/figures/sample_app_typography.png&quot; alt=&quot;sample\_app\_typography&quot;&gt;&lt;/p&gt;

&lt;p&gt;Figure 5.5: Adding some typographic styling. &lt;a href=&quot;http://railstutorial.org/images/figures/sample_app_typography-full.png&quot;&gt;(full
size)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最后，我们为网站的 LOGO 添加几条CSS规则，还要为我们的文字 “sample app”，设置大写，颜色，位置。x&lt;/p&gt;

&lt;p&gt;Listing 5.7. Adding CSS for the site logo. \
&lt;code&gt;app/assets/stylesheets/custom.css.scss&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;@import &amp;quot;bootstrap&amp;quot;;
.
.
.

/* header */

#logo {
  float: left;
  margin-right: 10px;
  font-size: 1.7em;
  color: #fff;
  text-transform: uppercase;
  letter-spacing: -1px;
  padding-top: 9px;
  font-weight: bold;
  line-height: 1;
}

#logo:hover {
  color: #fff;
  text-decoration: none;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的  &lt;code&gt;color: #fff&lt;/code&gt; 将 logo 的颜色改成白色。HTML 颜色可以用三对十六进制数表示，分别表示红，绿，蓝三色。代码 &lt;code&gt;#ffffff&lt;/code&gt; 是 &lt;code&gt;#fff&lt;/code&gt; 的完整形式，他们都表示纯白色。CSS 标准也允许使用很多特定名字来作为属性，&lt;a href=&quot;http://www.w3schools.com/html/html_colornames.asp&quot;&gt;HTML colors&lt;/a&gt;,例如这里可以使用 &lt;code&gt;white&lt;/code&gt; 来代替 &lt;code&gt;#fff&lt;/code&gt;。代码产生的结果如下：&lt;a href=&quot;filling-in-the-layout#code-logo_css&quot;&gt;Listing 5.7&lt;/a&gt; 
&lt;a href=&quot;filling-in-the-layout#fig-sample_app_logo&quot;&gt;Figure 5.6&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/figures/sample_app_logo.png&quot; alt=&quot;sample\_app\_logo&quot;&gt;&lt;/p&gt;

&lt;p&gt;Figure 5.6: The sample app with nicely styled logo. &lt;a href=&quot;http://railstutorial.org/images/figures/sample_app_logo-full.png&quot;&gt;(full
size)&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;filling-in-the-layout#sec-partials&quot;&gt;5.1.3 Partials&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;虽然我们已经在5.1之中完成了所有布局文件的内容，但是它看起来还是有一点 cluttered .  HTML 的注释和分割代码的功能非常薄弱，整个页面的代码都必须放在一个文件里。Rails想出了一个方法来解决这个问题，叫做 &lt;em&gt;partials&lt;/em&gt;. 让我们先看看经过 partials 处理之后的布局文件。&lt;/p&gt;

&lt;p&gt;(&lt;a href=&quot;filling-in-the-layout#code-layout_with_partials&quot;&gt;Listing 5.8&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Listing 5.8. The site layout with partials for the stylesheets and
header. \
&lt;code&gt;app/views/layouts/application.html.erb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;%= full_title(yield(:title)) %&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;%= stylesheet_link_tag    &amp;quot;application&amp;quot;, media: &amp;quot;all&amp;quot; %&amp;gt;
    &amp;lt;%= javascript_include_tag &amp;quot;application&amp;quot; %&amp;gt;
    &amp;lt;%= csrf_meta_tags %&amp;gt;
    &amp;lt;%= render &amp;#39;layouts/shim&amp;#39; %&amp;gt;    
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;%= render &amp;#39;layouts/header&amp;#39; %&amp;gt;
    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
      &amp;lt;%= yield %&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们注意到了，我们把烦人的 HTML 标注部分给换成了一个 Rails 的helper 叫 &lt;code&gt;render&lt;/code&gt;: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;%= render &amp;#39;layouts/shim&amp;#39; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这句话的效果是去寻找一个文件叫做 &lt;code&gt;app/views/layouts/_shim.html.erb&lt;/code&gt; ，处理文件中的内容之后吧结果插入到当前的视图文件之中。注意这里的文件名，文件名之前有一个下划线  &lt;code&gt;_shim.html.erb&lt;/code&gt;; 这个下划线使我们的 partial 文件和普通的视图文件区别开来，使我们能轻易地分辨他们。&lt;/p&gt;

&lt;p&gt;当然为了让 partial 运作起来，我们需要向其中加上一下内容，在这个 shim partial 中，我们只需要简单的三行代码就足够了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;filling-in-the-layout#code-stylesheets_partial&quot;&gt;Listing 5.9&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Listing 5.9. A partial for the HTML shim. \
&lt;code&gt;app/views/layouts/_shim.html.erb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;!--[if lt IE 9]&amp;gt;
&amp;lt;script src=&amp;quot;http://html5shim.googlecode.com/svn/trunk/html5.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;![endif]--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似地，我们可以把头部内容抽取出来放到另一个partial中，然后再加入一行 render 来调用。&lt;/p&gt;

&lt;p&gt;Listing 5.10. A partial for the site header. \
&lt;code&gt;app/views/layouts/_header.html.erb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;header class=&amp;quot;navbar navbar-fixed-top navbar-inverse&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;navbar-inner&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
      &amp;lt;%= link_to &amp;quot;sample app&amp;quot;, &amp;#39;#&amp;#39;, id: &amp;quot;logo&amp;quot; %&amp;gt;
      &amp;lt;nav&amp;gt;
        &amp;lt;ul class=&amp;quot;nav pull-right&amp;quot;&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Home&amp;quot;,    &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Help&amp;quot;,    &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Sign in&amp;quot;, &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/nav&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/header&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们知道了 partial 是怎么回事，我们来加入一个网站的 footer 部分吧。首先我们要在layouts目录下新建一个文件叫 &lt;code&gt;_footer.html.erb&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;(&lt;a href=&quot;filling-in-the-layout#code-footer_partial&quot;&gt;Listing 5.11&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Listing 5.11. A partial for the site footer. \
&lt;code&gt;app/views/layouts/_footer.html.erb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;footer class=&amp;quot;footer&amp;quot;&amp;gt;
  &amp;lt;small&amp;gt;
    &amp;lt;a href=&amp;quot;http://railstutorial.org/&amp;quot;&amp;gt;Rails Tutorial&amp;lt;/a&amp;gt;
    by Michael Hartl
  &amp;lt;/small&amp;gt;
  &amp;lt;nav&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;About&amp;quot;,   &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Contact&amp;quot;, &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;http://news.railstutorial.org/&amp;quot;&amp;gt;News&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;/nav&amp;gt;
&amp;lt;/footer&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和刚刚处理header的方式一样，在footer中我们使用了 &lt;code&gt;link_to&lt;/code&gt; 函数来链接 About 和 Content 页面，并暂时先用 &lt;code&gt;&amp;#39;#&amp;#39;&lt;/code&gt; 来代替目标地址，然后用同样的方法调用 render。 &lt;/p&gt;

&lt;p&gt;(&lt;a href=&quot;filling-in-the-layout#code-layout_with_footer&quot;&gt;Listing 5.12&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Listing 5.12. The site layout with a footer partial. \
&lt;code&gt;app/views/layouts/application.html.erb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;%= full_title(yield(:title)) %&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;%= stylesheet_link_tag    &amp;quot;application&amp;quot;, media: &amp;quot;all&amp;quot; %&amp;gt;
    &amp;lt;%= javascript_include_tag &amp;quot;application&amp;quot; %&amp;gt;
    &amp;lt;%= csrf_meta_tags %&amp;gt;
    &amp;lt;%= render &amp;#39;layouts/shim&amp;#39; %&amp;gt;    
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;%= render &amp;#39;layouts/header&amp;#39; %&amp;gt;
    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
      &amp;lt;%= yield %&amp;gt;
      &amp;lt;%= render &amp;#39;layouts/footer&amp;#39; %&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;footer 这时候还没有样式表支持，十分地丑陋。我们现在来给它润润色。&lt;/p&gt;

&lt;p&gt;Listing 5.13. Adding the CSS for the site footer. \
&lt;code&gt;app/assets/stylesheets/custom.css.scss&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;.
.
.

/* footer */

footer {
  margin-top: 45px;
  padding-top: 5px;
  border-top: 1px solid #eaeaea;
  color: #999;
}

footer a {
  color: #555;
}  

footer a:hover { 
  color: #222;
}

footer small {
  float: left;
}

footer ul {
  float: right;
  list-style: none;
}

footer ul li {
  float: left;
  margin-left: 10px;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/images/figures/site_with_footer_bootstrap.png&quot; alt=&quot;site\_with\_footer\_bootstrap&quot;&gt;&lt;/p&gt;

&lt;p&gt;Figure 5.7: The Home page
(&lt;a href=&quot;http://localhost:3000/static_pages/home&quot;&gt;/static_pages/home&lt;/a&gt;) 加上footer. &lt;a href=&quot;http://railstutorial.org/images/figures/site_with_footer_bootstrap-full.png&quot;&gt;(full
size)&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;filling-in-the-layout#sec-sass_and_the_asset_pipeline&quot;&gt;5.2 Sass 和 Asset pipeline&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Rails 3.0 和 当前版本的Rails 最引人关注的区别就是新版加入了 asset pipeline，显著地提升了管理例如 CSS  Javascript ，图片等静态资源的能力。在这一部分我们会大致地介绍 asset pipeline和其默认使用的 SASS 这个神奇的 CSS 工具。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;filling-in-the-layout#sec-the_asset_pipeline&quot;&gt;5.2.1 Asset Pipeline&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Asset Pipeline 的出现让Rails的内部结构改变了很多，但是从一个Rails开发人员的角度上来说，主要是有三个新增特性： asset 目录，文件清单，和预处理引擎。我们会依次介绍。&lt;/p&gt;

&lt;h4&gt;&lt;a href=&quot;filling-in-the-layout#sec-5_2_1_1&quot;&gt;Asset 目录&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;在Rails 3.0 之前( 包括 3.0 )，静态资源都放在  &lt;code&gt;public/&lt;/code&gt; 目录之下，包括了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  &lt;code&gt;public/stylesheets&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;  &lt;code&gt;public/javascripts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;  &lt;code&gt;public/images&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该目录下的资源将能够被例如 http://example.com/stylesheets  的路径访问到。&lt;/p&gt;

&lt;p&gt;而从 Rails 3.1 开始，将有三个目录来放置静态资源，但是他们又有一些分别：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  &lt;code&gt;app/assets&lt;/code&gt;: 应用程序所需静态资源 &lt;/li&gt;
&lt;li&gt;  &lt;code&gt;lib/assets&lt;/code&gt;: 为你自己程序所写的程序库静态资源&lt;/li&gt;
&lt;li&gt;  &lt;code&gt;vendor/assets&lt;/code&gt;: 第三方插件的静态资源 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你可能可以猜到，每个的目录下面都有三个资源类目录：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ ls app/assets/
images      javascripts stylesheets
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是我们就理解了为什么当时我们要把 &lt;code&gt;custom.css.scss&lt;/code&gt; 放置在&lt;code&gt;app/assets/stylesheets&lt;/code&gt; 的原因了吧。&lt;/p&gt;

&lt;h4&gt;&lt;a href=&quot;filling-in-the-layout#sec-5_2_1_2&quot;&gt;清单文件与管理静态资源&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;一旦你把你的静态资源布置到了指定的位置上之后，你只需要一个清单文件(通过&lt;a href=&quot;https://github.com/sstephenson/sprockets&quot;&gt;Sprockets&lt;/a&gt;这个gem)来告诉 Rails 到底如何把多个文件组合成单个文件。例如，我们可以看一下app目录下的样式表清单文件。&lt;/p&gt;

&lt;p&gt;(&lt;a href=&quot;filling-in-the-layout#code-app_css_manifest&quot;&gt;Listing 5.14&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Listing 5.14. The manifest file for app-specific CSS. \
&lt;code&gt;app/assets/stylesheets/application.css&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;/*
 * This is a manifest file that&amp;#39;ll automatically include all the stylesheets
 * available in this directory and any sub-directories. You&amp;#39;re free to add
 * application-wide styles to this file and they&amp;#39;ll appear at the top of the
 * compiled file, but it&amp;#39;s generally better to create a new file per style 
 * scope.
 *= require_self
 *= require_tree . 
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下一行虽然是CSS的注释，但是它们却会被Sprockets处理，把对应文件引入。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;/*
 .
 .
 .
 *= require_self
 *= require_tree . 
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;*= require_tree .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;保证了所有 &lt;code&gt;app/assets/stylesheets&lt;/code&gt; 目录下的 CSS 文件都被引入到应用中去。
而&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;*= require_self
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一行保证了 &lt;code&gt;application.css&lt;/code&gt;  文件本身也被引入。&lt;/p&gt;

&lt;p&gt;Rails 应用新建的时候就有一个默认的清单文件，而在本教程中我们不需要做任何的更改，你可以在 &lt;a href=&quot;http://guides.rubyonrails.org/asset_pipeline.html&quot;&gt;Rails Guides entry on the asset pipeline&lt;/a&gt; 中找到更多的信息。&lt;/p&gt;

&lt;h4&gt;&lt;a href=&quot;filling-in-the-layout#sec-5_2_1_3&quot;&gt;文件预处理&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;当你把你的静态文件准备妥当之后，Rails会根据你的文件清单进行预处理，之后通过Rails服务器传送给浏览器。文件的后缀指示出Rails要用什么如何处理对应的文件。例如使用Sass来处理  &lt;code&gt;.scss&lt;/code&gt; 后缀，用CoffeeScript处理 &lt;code&gt;.coffee&lt;/code&gt; ，用 Ruby 自带的 ERb 插件处理 &lt;code&gt;.erb&lt;/code&gt; 文件。ERb和Sass我们都在前文提到过，本教程中我们不会使用 CoffeScript，但是这是一个轻量而优雅的 Javascript 编译语言(建议从&lt;a href=&quot;http://railscasts.com/episodes/267-coffeescript-basics&quot;&gt;RailsCast on CoffeeScript basics&lt;/a&gt;开始CoffeeScript的学习)。&lt;/p&gt;

&lt;p&gt;预处理可以通过后缀的链接而依次执行，例如&lt;/p&gt;

&lt;p&gt;&lt;code&gt;foobar.js.coffee&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;将运行 CoffeeScript 处理器，而&lt;/p&gt;

&lt;p&gt;&lt;code&gt;foobar.js.erb.coffee&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;将运行CoffeeScript 处理器之后再执行 ERb 处理。&lt;/p&gt;

&lt;h4&gt;&lt;a href=&quot;filling-in-the-layout#sec-5_2_1_4&quot;&gt;高效的生产模式&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;asset pipeline 中最棒的事情就是其能够在生产模式中大大优化服务器的效率。传统的服务器是将 CSS 和 JavaScript 逐文件地传送至浏览器上。虽然这样便于开发，但是却大大增加客户端的载入时间(客户的交互速度是应用设计重要环节)。然而通过 asset pipeline ,在生产模式中所有应用的样式表和脚本代码将会分别合并压缩成单个文件(&lt;code&gt;application.css&lt;/code&gt;和`javascripts.js),并且排除掉页面上无需载入的文件，大大方便了编程人员，也加速了页面的访问速度。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;filling-in-the-layout#sec-sass&quot;&gt;5.2.2 强化语法样式表&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Sass&lt;/em&gt;  是一种为了改善CSS语言而存在的工具。在这一节，我们将会对CSS进行两项重要的优化，为CSS加上 &lt;em&gt;nesting&lt;/em&gt; 和 变量。(我们还会在 &lt;a href=&quot;sign-up#sec-rails_environments&quot;&gt;Section 7.1.1&lt;/a&gt;加上第三个技术 &lt;em&gt;mixins&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;我们曾经在&lt;a href=&quot;filling-in-the-layout#sec-custom_css&quot;&gt;Section 5.1.2&lt;/a&gt;中提到，Sass支持SCSS格式的文件(用 &lt;code&gt;.scss&lt;/code&gt; 当作后缀)，该技术完全对CSS兼容————这意味着你完全可以在一个scss文件中写满css语法.最初，我们是因为Bootstrap中要用上SASS，而事实上，Rails 的asset pipeline 支持Sass的处理，Rails会自动地识别scss后缀的文件，并使用SASS软件进行预处理。&lt;/p&gt;

&lt;h4&gt;&lt;a href=&quot;filling-in-the-layout#sec-5_2_2_1&quot;&gt;Nesting&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;一种样式表中常见的形式就是内嵌。例如在下面我们把&lt;code&gt;.center h1&lt;/code&gt; 表示存在于 &lt;code&gt;.center&lt;/code&gt; 的属性中。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;.center {
  text-align: center;
}

.center h1 {
  margin-bottom: 10px;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Sass 中，我们可以这么表示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;.center {
  text-align: center;
  h1 {
    margin-bottom: 10px;
  }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的 &lt;code&gt;h1&lt;/code&gt; 就将自动继承上文的 &lt;code&gt;.center&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;还有另外一个例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;#logo {
  float: left;
  margin-right: 10px;
  font-size: 1.7em;
  color: #fff;
  text-transform: uppercase;
  letter-spacing: -1px;
  padding-top: 9px;
  font-weight: bold;
  line-height: 1;
}

#logo:hover {
  color: #fff;
  text-decoration: none;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里id为 &lt;code&gt;#logo&lt;/code&gt; 的元素出现了两次，一次是定义自己的属性，另一次是定义其 &lt;code&gt;hover&lt;/code&gt; 状态的属性。在SCSS文件中，我们就可以运用 &lt;code&gt;&amp;amp;&lt;/code&gt; 更优雅地表达我们的语句：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;#logo {
  float: left;
  margin-right: 10px;
  font-size: 1.7em;
  color: #fff;
  text-transform: uppercase;
  letter-spacing: -1px;
  padding-top: 9px;
  font-weight: bold;
  line-height: 1;
  &amp;amp;:hover {
    color: #fff;
    text-decoration: none;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Sass在进行处理的时候会把 把&lt;code&gt;&amp;amp;:hover&lt;/code&gt; 转换为 &lt;code&gt;#logo:hover&lt;/code&gt; 的CSS语法。&lt;/p&gt;

&lt;p&gt;我们再把这两种nesting技巧运用到我们footer段的CSS文件中，把它改写成这样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;footer {
  margin-top: 45px;
  padding-top: 5px;
  border-top: 1px solid #eaeaea;
  color: #999;
  a {
    color: #555;
    &amp;amp;:hover { 
      color: #222;
    }
  }  
  small { 
    float: left; 
  }
  ul {
    float: right;
    list-style: none;
    li {
      float: left;
      margin-left: 10px;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码是一个好很的练习机会，改写后你会发现页面并没有出现改变。&lt;/p&gt;

&lt;h4&gt;&lt;a href=&quot;filling-in-the-layout#sec-5_2_2_2&quot;&gt;变量&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Sass 可以让我们可以使用变量来减少重复的表达式代码。如下，我们出现了一个语句的重复&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;h2 {
  .
  .
  .
  color: #999;
}
.
.
.
footer {
  .
  .
  .
  color: #999;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里  &lt;code&gt;#999&lt;/code&gt;  是亮灰色，我们可以给它一个一个变量名：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$lightGray: #999;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们可以这么撰写SCSS文件：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$lightGray: #999;
.
.
.
h2 {
  .
  .
  .
  color: $lightGray;
}
.
.
.
footer {
  .
  .
  .
  color: $lightGray;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;变量名 &lt;code&gt;$lightGray&lt;/code&gt;，比原本的 &lt;code&gt;#999&lt;/code&gt; 显得更加简单易懂，这种技巧常常运用在一块代码中出现了多次重复的表达式时。事实上，Bootstrap框架已经定义了很多种的颜色，公布在网上， &lt;a href=&quot;http://bootstrapdocs.com/v2.0.4/docs/less.html&quot;&gt;Bootstrap中的LESS&lt;/a&gt;，这里定义的时候用的是LESS语法，但是我们加入了 &lt;code&gt;bootstrap-sass&lt;/code&gt; gem之后，同样的变量也被移植了过来。看出来其和Sass的对应关系应该不是什么难事，Less在 &amp;quot;@&amp;quot; 符号的地方用 &amp;quot;at&amp;quot; , Sass使用美元符号 &lt;code&gt;$&lt;/code&gt;.看Bootstrap的变量，我们发现有一行定义：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;@grayLight: #999;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这意味着，在使用了 &lt;code&gt;bootstrap-sass&lt;/code&gt; gem 的Rails应用中，我们直接写上&lt;code&gt;$lightGray&lt;/code&gt;就可以获得所需要的功能：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;h2 {
  .
  .
  .
  color: $grayLight;
}
.
.
.
footer {
  .
  .
  .
  color: $grayLight;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应用上Sass的技巧之后我们整个SCSS文件变成了这样。&lt;/p&gt;

&lt;p&gt;Listing 5.15. The initial SCSS file converted to use nesting and
variables. \
&lt;code&gt;app/assets/stylesheets/custom.css.scss&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;@import &amp;quot;bootstrap&amp;quot;;

/* mixins, variables, etc. */

$grayMediumLight: #eaeaea;

/* universal */

html {
  overflow-y: scroll;
}

body {
  padding-top: 60px;
}

section {
  overflow: auto;
}

textarea {
  resize: vertical;
}

.center {
  text-align: center;
  h1 {
    margin-bottom: 10px;
  }
}

/* typography */

h1, h2, h3, h4, h5, h6 {
  line-height: 1;
}

h1 {
  font-size: 3em;
  letter-spacing: -2px;
  margin-bottom: 30px;
  text-align: center;
}

h2 {
  font-size: 1.7em;
  letter-spacing: -1px;
  margin-bottom: 30px;
  text-align: center;
  font-weight: normal;
  color: $grayLight;
}

p {
  font-size: 1.1em;
  line-height: 1.7em;
}


/* header */

#logo {
  float: left;
  margin-right: 10px;
  font-size: 1.7em;
  color: white;
  text-transform: uppercase;
  letter-spacing: -1px;
  padding-top: 9px;
  font-weight: bold;
  line-height: 1;
  &amp;amp;:hover {
    color: white;
    text-decoration: none;
  }
}

/* footer */

footer {
  margin-top: 45px;
  padding-top: 5px;
  border-top: 1px solid $grayMediumLight;
  color: $grayLight;
  a {
    color: $gray;
    &amp;amp;:hover { 
      color: $grayDarker;
    }
  }  
  small { 
    float: left; 
  }
  ul {
    float: right;
    list-style: none;
    li {
      float: left;
      margin-left: 10px;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Sass给了我们简化样式表的手段，但是这只是Sass强大功能的冰山一角，如果你有兴趣，可以参照 &lt;a href=&quot;http://sass-lang.com/&quot;&gt;Sass website&lt;/a&gt; 获取更多信息。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;filling-in-the-layout#sec-layout_links&quot;&gt;5.3 Layout 链接&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;我们已经完成了网站的布局样式代码，现在是时候让我们把原本预留的 &lt;code&gt;’#’&lt;/code&gt; 链接替换成其他的链接了。当然，我们可以用这样的硬编码来实现&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;a href=&amp;quot;/static_pages/about&amp;quot;&amp;gt;About&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这就没有 Rails 的感觉了。一般来说，对于URI，使用 /about 会比 /static_pages/about 更好一点，在Rails 中，Rails 通常使用  &lt;em&gt;named routes&lt;/em&gt; ，代码看起来可能像这样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;%= link_to &amp;quot;About&amp;quot;, about_path %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的代码能够更加明确地说明代码含义，并且可移植性更强。&lt;/p&gt;

&lt;p&gt;下面这个列表是我们准备在首页上实现的所有URI链接和路由配置,我们将会依次实现它们。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Page&lt;/strong&gt;   &lt;strong&gt;URI&lt;/strong&gt;    &lt;strong&gt;Named route&lt;/strong&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Home       /          &lt;code&gt;root_path&lt;/code&gt;
  About      /about     &lt;code&gt;about_path&lt;/code&gt;
  Help       /help      &lt;code&gt;help_path&lt;/code&gt;
  Contact    /contact   &lt;code&gt;contact_path&lt;/code&gt;
  Sign up    /signup    &lt;code&gt;signup_path&lt;/code&gt;
  Sign in    /signin    &lt;code&gt;signin_path&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Table 5.1: Route and URI mapping for site links.&lt;/p&gt;

&lt;p&gt;首先，我们先加入一个内容页面，在这之前我们要先写测试代码。&lt;/p&gt;

&lt;p&gt;Listing 5.16. Tests for a Contact page. \
&lt;code&gt;spec/requests/static_pages_spec.rb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;require &amp;#39;spec_helper&amp;#39;

describe &amp;quot;Static pages&amp;quot; do
  .
  .
  .
  describe &amp;quot;Contact page&amp;quot; do

    it &amp;quot;should have the h1 &amp;#39;Contact&amp;#39;&amp;quot; do
      visit &amp;#39;/static_pages/contact&amp;#39;
      page.should have_selector(&amp;#39;h1&amp;#39;, text: &amp;#39;Contact&amp;#39;)
    end

    it &amp;quot;should have the title &amp;#39;Contact&amp;#39;&amp;quot; do
      visit &amp;#39;/static_pages/contact&amp;#39;
      page.should have_selector(&amp;#39;title&amp;#39;,
                    text: &amp;quot;Ruby on Rails Tutorial Sample App | Contact&amp;quot;)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以进行测试，它很理所应当地失败了。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle exec rspec spec/requests/static_pages_spec.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后，我们为我们加上路由配置，我们为 StaticPages 控制器加上了一个&lt;code&gt;contact&lt;/code&gt; 行为，最后我们新建了一个 Contact 的视图。&lt;/p&gt;

&lt;p&gt;Listing 5.17. Adding a route for the Contact page. \
&lt;code&gt;config/routes.rb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;SampleApp::Application.routes.draw do
  get &amp;quot;static_pages/home&amp;quot;
  get &amp;quot;static_pages/help&amp;quot;
  get &amp;quot;static_pages/about&amp;quot;
  get &amp;quot;static_pages/contact&amp;quot;
  .
  .
  .
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Listing 5.18. Adding an action for the Contact page. \
&lt;code&gt;app/controllers/static_pages_controller.rb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;class StaticPagesController &amp;lt; ApplicationController
  .
  .
  .
  def contact
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Listing 5.19. The view for the Contact page. \
&lt;code&gt;app/views/static_pages/contact.html.erb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;% provide(:title, &amp;#39;Contact&amp;#39;) %&amp;gt;
&amp;lt;h1&amp;gt;Contact&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;
  Contact Ruby on Rails Tutorial about the sample app at the
  &amp;lt;a href=&amp;quot;http://railstutorial.org/contact&amp;quot;&amp;gt;contact page&amp;lt;/a&amp;gt;.
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在那个测试应该是通过了。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle exec rspec spec/requests/static_pages_spec.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;filling-in-the-layout#sec-route_tests&quot;&gt;5.3.1 路由测试&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;我们现在已经成功地完成了静态页面的测试，下一步是测试路由的正常运作。撰写一个路由测试很简单：我们只要把每一个硬编码的路由路径改为命名路由路径即可，例如我们把&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;visit &amp;#39;/static_pages/about&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改为&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;visit about_path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他的页面也类似，最后页面样式这样：&lt;/p&gt;

&lt;p&gt;Listing 5.20. Tests for the named routes. \
&lt;code&gt;spec/requests/static_pages_spec.rb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;require &amp;#39;spec_helper&amp;#39;

describe &amp;quot;Static pages&amp;quot; do

  describe &amp;quot;Home page&amp;quot; do

    it &amp;quot;should have the h1 &amp;#39;Sample App&amp;#39;&amp;quot; do
      visit root_path
      page.should have_selector(&amp;#39;h1&amp;#39;, text: &amp;#39;Sample App&amp;#39;)
    end

    it &amp;quot;should have the base title&amp;quot; do
      visit root_path
      page.should have_selector(&amp;#39;title&amp;#39;,
                        text: &amp;quot;Ruby on Rails Tutorial Sample App&amp;quot;)
    end

    it &amp;quot;should not have a custom page title&amp;quot; do
      visit root_path
      page.should_not have_selector(&amp;#39;title&amp;#39;, text: &amp;#39;| Home&amp;#39;)
    end
  end

  describe &amp;quot;Help page&amp;quot; do

    it &amp;quot;should have the h1 &amp;#39;Help&amp;#39;&amp;quot; do
      visit help_path
      page.should have_selector(&amp;#39;h1&amp;#39;, text: &amp;#39;Help&amp;#39;)
    end

    it &amp;quot;should have the title &amp;#39;Help&amp;#39;&amp;quot; do
      visit help_path
      page.should have_selector(&amp;#39;title&amp;#39;,
                        text: &amp;quot;Ruby on Rails Tutorial Sample App | Help&amp;quot;)
    end
  end

  describe &amp;quot;About page&amp;quot; do

    it &amp;quot;should have the h1 &amp;#39;About&amp;#39;&amp;quot; do
      visit about_path
      page.should have_selector(&amp;#39;h1&amp;#39;, text: &amp;#39;About Us&amp;#39;)
    end

    it &amp;quot;should have the title &amp;#39;About Us&amp;#39;&amp;quot; do
      visit about_path
      page.should have_selector(&amp;#39;title&amp;#39;,
                    text: &amp;quot;Ruby on Rails Tutorial Sample App | About Us&amp;quot;)
    end
  end

  describe &amp;quot;Contact page&amp;quot; do

    it &amp;quot;should have the h1 &amp;#39;Contact&amp;#39;&amp;quot; do
      visit contact_path
      page.should have_selector(&amp;#39;h1&amp;#39;, text: &amp;#39;Contact&amp;#39;)
    end

    it &amp;quot;should have the title &amp;#39;Contact&amp;#39;&amp;quot; do
      visit contact_path
      page.should have_selector(&amp;#39;title&amp;#39;,
                    text: &amp;quot;Ruby on Rails Tutorial Sample App | Contact&amp;quot;)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和往常一样，我们先看看我们错误百出的测试。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle exec rspec spec/requests/static_pages_spec.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你觉得文中的代码反复而冗长，别担心，你不是唯一这么想的人，我们很快就会对该页面进行改进的。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;filling-in-the-layout#sec-rails_routes&quot;&gt;5.3.2 Rails 路由&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;现在我们已经如我们所愿测试了URI，是时候让它们跑起来看看了。另外提一句，我们在打开 &lt;code&gt;config/routes.rb&lt;/code&gt; 文件的时候我们看到了默认路由中密密麻麻的注释代码，事实上，这些被注释的代码是对Rails路由语法的一种示例，你可以在这里&lt;a href=&quot;http://guides.rubyonrails.org/routing.html&quot;&gt;Rails Guides article “Rails Routing from the outside in”&lt;/a&gt;找到关于Rails路由的更多信息。&lt;/p&gt;

&lt;p&gt;要定义一个命名路由，我们首先要把get规则替换成match规则&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;get &amp;#39;static_pages/help&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改成&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;match &amp;#39;/help&amp;#39;, to: &amp;#39;static_pages#help&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样让  &lt;code&gt;/help&lt;/code&gt; 和命名路由 &lt;code&gt;help_path&lt;/code&gt; 都将能返回我们所需要的路径。在这里，get 和 match 其实结果都是一样的，但是实用 match 会更方便一点。&lt;/p&gt;

&lt;p&gt;我们只有在 Home 页面中使用静态的路由配置.&lt;/p&gt;

&lt;p&gt;Listing 5.21. Routes for static pages. \
&lt;code&gt;config/routes.rb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;SampleApp::Application.routes.draw do
  match &amp;#39;/help&amp;#39;,    to: &amp;#39;static_pages#help&amp;#39;
  match &amp;#39;/about&amp;#39;,   to: &amp;#39;static_pages#about&amp;#39;
  match &amp;#39;/contact&amp;#39;, to: &amp;#39;static_pages#contact&amp;#39;
  .
  .
  .
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你仔细地阅读了上面的代码，你一定能明白它说的是什么意思。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;match &amp;#39;/about&amp;#39;, to: &amp;#39;static_pages#about&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里将匹配 &amp;#39;/about&amp;#39; 路径到 StaticPages 控制器 下的 &lt;code&gt;about&lt;/code&gt; 方法。之前，我们用了更易懂的方法来处理： &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;get &amp;#39;static_pages/about&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这其实是同样的意思，但是 &lt;code&gt;/about&lt;/code&gt; 显得更简洁一点。正如上文所提到的。 &lt;code&gt;match ’/about’&lt;/code&gt; 同样为控制器和视图产生了命名路由：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;about_path =&amp;gt; &amp;#39;/about&amp;#39;
about_url  =&amp;gt; &amp;#39;http://localhost:3000/about&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，&lt;code&gt;about_url&lt;/code&gt; 生成的是完整的 URI 地址  http://localhost:3000/about。（在部署的时候，&lt;code&gt;localhost:3000&lt;/code&gt; 会被替换成域名，例如 &lt;code&gt;example.com&lt;/code&gt; 。）正如我们在&lt;a href=&quot;filling-in-the-layout#sec-layout_links&quot;&gt;Section 5.3&lt;/a&gt;中讨论的那样，要访问/about,你可以用 &lt;code&gt;about_path&lt;/code&gt; 。在  &lt;em&gt;Rails Tutorial&lt;/em&gt; 中，通常使用 &lt;code&gt;path&lt;/code&gt;。然而当我们我们需要进行重定向的时候，我们将需要完整的 HTTP 地址，这时候我们将会用 &lt;code&gt;url&lt;/code&gt; 后缀的格式，事实上，大部分浏览器这两种格式都是支持的。&lt;/p&gt;

&lt;p&gt;路由定义好了之后，我们可以开始测试 Help, About,Contact 页面了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle exec rspec spec/requests/static_pages_spec.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候应该只有 Home 页面还是处于fail状态。&lt;/p&gt;

&lt;p&gt;要建立路由的Home页面，我们可以用这样的代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;match &amp;#39;/&amp;#39;, to: &amp;#39;static_pages#home&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而这是没有必要的，因为在Rails中存在一个特殊的指令来表示 URI / 表示文件的最底层。&lt;/p&gt;

&lt;p&gt;Listing 5.22. The commented-out hint for defining the root route. \
&lt;code&gt;config/routes.rb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;SampleApp::Application.routes.draw do
  .
  .
  .
  # You can have the root of your site routed with &amp;quot;root&amp;quot;
  # just remember to delete public/index.html.
  # root :to =&amp;gt; &amp;quot;welcome#index&amp;quot;
  .
  .
  .
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using &lt;a href=&quot;filling-in-the-layout#code-root_route_hint&quot;&gt;Listing 5.22&lt;/a&gt; as a
model, we arrive at
&lt;a href=&quot;filling-in-the-layout#code-root_route&quot;&gt;Listing 5.23&lt;/a&gt; to route the root
URI / to the Home page.&lt;/p&gt;

&lt;p&gt;Listing 5.23. Adding a mapping for the root route. \
&lt;code&gt;config/routes.rb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;SampleApp::Application.routes.draw do
  root to: &amp;#39;static_pages#home&amp;#39;

  match &amp;#39;/help&amp;#39;,    to: &amp;#39;static_pages#help&amp;#39;
  match &amp;#39;/about&amp;#39;,   to: &amp;#39;static_pages#about&amp;#39;
  match &amp;#39;/contact&amp;#39;, to: &amp;#39;static_pages#contact&amp;#39;  
  .
  .
  .
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这代码将根URI / 映射到  /static_pages/home，并且建立这样的Helper函数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;root_path =&amp;gt; &amp;#39;/&amp;#39;
root_url  =&amp;gt; &amp;#39;http://localhost:3000/&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们需要留心提到过的&lt;a href=&quot;filling-in-the-layout#code-root_route_hint&quot;&gt;Listing 5.22&lt;/a&gt; 中删除 &lt;code&gt;public/index.html&lt;/code&gt; 文件的问题。
删除了之后，如果你有用 git 进行代码管理，还需要运行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git rm public/index.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来保证 git 删除了该文件。我们曾经在&lt;a href=&quot;beginning#sec-git_commands&quot;&gt;Section 1.3.5&lt;/a&gt;提到过了git的基本命令， 我们使用了Git命令   &lt;code&gt;git commit -a -m &amp;quot;Message&amp;quot;&lt;/code&gt; 其中-a为 ”all changes “， -m 为message。作为缩写，Git 支持把两个标签缩写成一个，变成 &lt;code&gt;git commit -am &amp;quot;Message&amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;现在，所有的路由设置与静态页面都已经完成了，现在的测试就会通过：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle exec rspec spec/requests/static_pages_spec.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们只是需要把链接写入布局文件中就可以了。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;filling-in-the-layout#sec-named_routes&quot;&gt;5.3.3 命名路由&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;让我们在把&lt;a href=&quot;filling-in-the-layout#sec-rails_routes&quot;&gt;Section 5.3.2&lt;/a&gt; 中写好的路由名称填到布局文件中来。我们只要把对应的路由命填到 &lt;code&gt;link_to&lt;/code&gt;  的第二个参数中就可以了，例如，我们把&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;%= link_to &amp;quot;About&amp;quot;, &amp;#39;#&amp;#39; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改成&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;%= link_to &amp;quot;About&amp;quot;, about_path %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就好。&lt;/p&gt;

&lt;p&gt;我们从 header partial 开始，&lt;code&gt;_header.html.erb&lt;/code&gt; 中有着 Home 和 Help 页面的链接，我们对他们作一些修改:&lt;/p&gt;

&lt;p&gt;Listing 5.24. Header partial with links. \
&lt;code&gt;app/views/layouts/_header.html.erb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;header class=&amp;quot;navbar navbar-fixed-top navbar-inverse&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;navbar-inner&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
      &amp;lt;%= link_to &amp;quot;sample app&amp;quot;, root_path, id: &amp;quot;logo&amp;quot; %&amp;gt;
      &amp;lt;nav&amp;gt;
        &amp;lt;ul class=&amp;quot;nav pull-right&amp;quot;&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Home&amp;quot;,    root_path %&amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Help&amp;quot;,    help_path %&amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Sign in&amp;quot;, &amp;#39;#&amp;#39; %&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/nav&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/header&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在第八章才会开始制作登录界面，所以我们先留一个 &lt;code&gt;’#’&lt;/code&gt; 在这里。&lt;/p&gt;

&lt;p&gt;而在 footer partial文件中， &lt;code&gt;_footer.html.erb&lt;/code&gt;,我们需要修改 About 和 Contact 页面。&lt;/p&gt;

&lt;p&gt;Listing 5.25. Footer partial with links. \
&lt;code&gt;app/views/layouts/_footer.html.erb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;footer class=&amp;quot;footer&amp;quot;&amp;gt;
  &amp;lt;small&amp;gt;
    &amp;lt;a href=&amp;quot;http://railstutorial.org/&amp;quot;&amp;gt;Rails Tutorial&amp;lt;/a&amp;gt;
    by Michael Hartl
  &amp;lt;/small&amp;gt;
  &amp;lt;nav&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;About&amp;quot;,   about_path %&amp;gt;&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;&amp;lt;%= link_to &amp;quot;Contact&amp;quot;, contact_path %&amp;gt;&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;http://news.railstutorial.org/&amp;quot;&amp;gt;News&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;/nav&amp;gt;
&amp;lt;/footer&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，我们已经把页面文件中所有的静态页面链接上了。&lt;/p&gt;

&lt;p&gt;另外，值得一提的是，一旦填上了对应的Helper名，测试就会自动检测是否存在对应的路由定义。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/figures/about_page_styled.png&quot; alt=&quot;about\_page\_styled&quot;&gt;&lt;/p&gt;

&lt;p&gt;Figure 5.8: The About page at
&lt;a href=&quot;http://localhost:3000/about&quot;&gt;/about&lt;/a&gt;. &lt;a href=&quot;http://railstutorial.org/images/figures/about_page_styled-full.png&quot;&gt;(full
size)&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;filling-in-the-layout#sec-pretty_rspec&quot;&gt;5.3.4 为RSpec锦上添花&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;我们注意到在 &lt;a href=&quot;filling-in-the-layout#sec-route_tests&quot;&gt;Section 5.3.1&lt;/a&gt; 中，我们的测试文件有一些冗长和重复。在这一节里，我们将会用上 Rspec 的新特性来让代码显得更优雅。&lt;/p&gt;

&lt;p&gt;先关注一下我们原本的代码是怎么样的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;describe &amp;quot;Home page&amp;quot; do

  it &amp;quot;should have the h1 &amp;#39;Sample App&amp;#39;&amp;quot; do
    visit root_path
    page.should have_selector(&amp;#39;h1&amp;#39;, text: &amp;#39;Sample App&amp;#39;)
  end

  it &amp;quot;should have the base title&amp;quot; do
    visit root_path
    page.should have_selector(&amp;#39;title&amp;#39;,
                      text: &amp;quot;Ruby on Rails Tutorial Sample App&amp;quot;)
  end

  it &amp;quot;should not have a custom page title&amp;quot; do
    visit root_path
    page.should_not have_selector(&amp;#39;title&amp;#39;, text: &amp;#39;| Home&amp;#39;)
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先被注意到的是所有的例子都包含了一个 visit 到 root path 的属性。我们可以通过使  用 &lt;code&gt;before&lt;/code&gt; 代码块来处理它：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;describe &amp;quot;Home page&amp;quot; do
  before { visit root_path } 

  it &amp;quot;should have the h1 &amp;#39;Sample App&amp;#39;&amp;quot; do
    page.should have_selector(&amp;#39;h1&amp;#39;, text: &amp;#39;Sample App&amp;#39;)
  end

  it &amp;quot;should have the base title&amp;quot; do
    page.should have_selector(&amp;#39;title&amp;#39;,
                      text: &amp;quot;Ruby on Rails Tutorial Sample App&amp;quot;)
  end

  it &amp;quot;should not have a custom page title&amp;quot; do
    page.should_not have_selector(&amp;#39;title&amp;#39;, text: &amp;#39;| Home&amp;#39;)
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们修改了这一行&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;before { visit root_path }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样保证了每一个测试都是在访问 root path.&lt;/p&gt;

&lt;p&gt;另一个重复代码是&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;it &amp;quot;should have the h1 &amp;#39;Sample App&amp;#39;&amp;quot; do
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;page.should have_selector(&amp;#39;h1&amp;#39;, text: &amp;#39;Sample App&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个表达的其实是一样的事情。这里我们注意到，每个测试都引用了&lt;code&gt;page&lt;/code&gt;变量，我们可以运用 Rspec 的  &lt;em&gt;subject&lt;/em&gt;  语法来消除这一冗余。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;subject { page }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且在单行的 it 语法中，我们使用闭合式的代码块表示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;it { should have_selector(&amp;#39;h1&amp;#39;, text: &amp;#39;Sample App&amp;#39;) }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为我们申明了 &lt;code&gt;subject { page }&lt;/code&gt;，所以调用 &lt;code&gt;should&lt;/code&gt; 时 Capybara 会自动帮你选择使用page变量。&lt;/p&gt;

&lt;p&gt;现在，Home 页面的测试代码显得更加紧凑和优雅了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;  subject { page }

  describe &amp;quot;Home page&amp;quot; do
    before { visit root_path } 

    it { should have_selector(&amp;#39;h1&amp;#39;, text: &amp;#39;Sample App&amp;#39;) }
    it { should have_selector &amp;#39;title&amp;#39;,
                        text: &amp;quot;Ruby on Rails Tutorial Sample App&amp;quot; }
    it { should_not have_selector &amp;#39;title&amp;#39;, text: &amp;#39;| Home&amp;#39; }
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的代码看起来好多了。但是测试的标题看起来还是长了一点，事实上，在每一个测试的开头都有一行这样的长标题：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;quot;Ruby on Rails Tutorial Sample App | About&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 &lt;a href=&quot;static-pages#sec-static_pages_exercises&quot;&gt;Section 3.5&lt;/a&gt; 的练习中，我们试着定义一个 &lt;code&gt;base_title&lt;/code&gt; 变量来消除重复的标题字符串。现在，我们有更好的办法：定义一个 &lt;code&gt;full_title&lt;/code&gt; 函数。为此，我们需要建立 &lt;code&gt;spec/support&lt;/code&gt; 文件夹和 &lt;code&gt;utilities.rb&lt;/code&gt;  文件。&lt;/p&gt;

&lt;p&gt;Listing 5.26. A file for RSpec utilities with a &lt;code&gt;full_title&lt;/code&gt; function. \
&lt;code&gt;spec/support/utilities.rb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;def full_title(page_title)
  base_title = &amp;quot;Ruby on Rails Tutorial Sample App&amp;quot;
  if page_title.empty?
    base_title
  else
    &amp;quot;#{base_title} | #{page_title}&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实，这函数本质上还是我们在&lt;a href=&quot;rails-flavored-ruby#code-title_helper&quot;&gt;Listing 4.2&lt;/a&gt;中写的那个。但是两个独立的函数允许我们更加自由地组织我们的标题。这是一种很奇怪的设计，而更好的方法我们会在测试(&lt;a href=&quot;filling-in-the-layout#sec-layout_exercises&quot;&gt;Section 5.6&lt;/a&gt;)给出。&lt;/p&gt;

&lt;p&gt;在  &lt;code&gt;spec/support&lt;/code&gt;  目录下的文件夹默认包括了 RSpec，这意味着我们可以在写 Home 页面测试可以这样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;  subject { page }

  describe &amp;quot;Home page&amp;quot; do
    before { visit root_path } 

    it { should have_selector(&amp;#39;h1&amp;#39;,    text: &amp;#39;Sample App&amp;#39;) }
    it { should have_selector(&amp;#39;title&amp;#39;, text: full_title(&amp;#39;&amp;#39;)) }
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就可以轻松地对 Home 页面照葫芦花瓢，写出我们的 Help, About, 和 Contact 页面。结果如下&lt;/p&gt;

&lt;p&gt;Listing 5.27. Prettier tests for the static pages. \
&lt;code&gt;spec/requests/static_pages_spec.rb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;require &amp;#39;spec_helper&amp;#39;

describe &amp;quot;Static pages&amp;quot; do

  subject { page }

  describe &amp;quot;Home page&amp;quot; do
    before { visit root_path }

    it { should have_selector(&amp;#39;h1&amp;#39;,    text: &amp;#39;Sample App&amp;#39;) }
    it { should have_selector(&amp;#39;title&amp;#39;, text: full_title(&amp;#39;&amp;#39;)) }
    it { should_not have_selector &amp;#39;title&amp;#39;, text: &amp;#39;| Home&amp;#39; }
  end

  describe &amp;quot;Help page&amp;quot; do
    before { visit help_path }

    it { should have_selector(&amp;#39;h1&amp;#39;,    text: &amp;#39;Help&amp;#39;) }
    it { should have_selector(&amp;#39;title&amp;#39;, text: full_title(&amp;#39;Help&amp;#39;)) }
  end

  describe &amp;quot;About page&amp;quot; do
    before { visit about_path }

    it { should have_selector(&amp;#39;h1&amp;#39;,    text: &amp;#39;About&amp;#39;) }
    it { should have_selector(&amp;#39;title&amp;#39;, text: full_title(&amp;#39;About Us&amp;#39;)) }
  end

  describe &amp;quot;Contact page&amp;quot; do
    before { visit contact_path }

    it { should have_selector(&amp;#39;h1&amp;#39;,    text: &amp;#39;Contact&amp;#39;) }
    it { should have_selector(&amp;#39;title&amp;#39;, text: full_title(&amp;#39;Contact&amp;#39;)) }
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，我们现在可以进行测试，修改你的代码知道让他们全部通过：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle exec rspec spec/requests/static_pages_spec.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;a href=&quot;filling-in-the-layout#sec-user_signup&quot;&gt;5.4 新的开始：用户注册&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;有了完整的 Rails 页面布局与路由作为一个基础，在这一章，我们要开始写用户注册界面，着意味着我们需要一个新的控制器。用户注册是用户在网站中的入口，是交互中极其重要的一环，在这一章我们会作出控制器，在下一章，我们会完成用户模型的搭建，我们会在第七章完成注册页面的工作。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;filling-in-the-layout#sec-users_controller&quot;&gt;5.4.1 用户控制器&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;上一个控制器似乎已经是非常遥远的事情了，StaticPages controller，要追溯到&lt;a href=&quot;static-pages#sec-static_pages_with_rails&quot;&gt;Section 3.1.2&lt;/a&gt;，是时候新建一个新控制器了： User controller .  和原来一样，我们需要运行 &lt;code&gt;generate&lt;/code&gt; 命令来创建用户注册控制器的基础框架。根据我们之前提到的 &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_State_Transfer&quot;&gt;REST 架构&lt;/a&gt; ，我们要建立一个 建立用户的行为 &lt;code&gt;new&lt;/code&gt;， 我们可以把 new 作为一个参数传给  &lt;code&gt;generate controller&lt;/code&gt; 命令。&lt;/p&gt;

&lt;p&gt;Listing 5.28. Generating a Users controller (with a &lt;code&gt;new&lt;/code&gt; action).&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rails generate controller Users new --no-test-framework
      create  app/controllers/users_controller.rb
       route  get &amp;quot;users/new&amp;quot;
      invoke  erb
      create    app/views/users
      create    app/views/users/new.html.erb
      invoke  helper
      create    app/helpers/users_helper.rb
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/users.js.coffee
      invoke    scss
      create      app/assets/stylesheets/users.css.scss
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，我们就创建了一个包含new行为的用户控制器，同时还新建了一个简单用户页面：&lt;/p&gt;

&lt;p&gt;Listing 5.29. The initial Users controller, with a &lt;code&gt;new&lt;/code&gt; action. \
&lt;code&gt;app/controllers/users_controller.rb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;class UsersController &amp;lt; ApplicationController
  def new
  end

end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Listing 5.30. The initial &lt;code&gt;new&lt;/code&gt; action for Users. \
&lt;code&gt;app/views/users/new.html.erb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;h1&amp;gt;Users#new&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;Find me in app/views/users/new.html.erb&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a href=&quot;filling-in-the-layout#sec-signup_url&quot;&gt;5.4.2 注册 URI&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;完成了&lt;a href=&quot;filling-in-the-layout#sec-users_controller&quot;&gt;Section 5.4.1&lt;/a&gt;之后，我们已经在  /users/new 地址处获得了一个页面，但是根据我们在 &lt;a href=&quot;filling-in-the-layout#table-url_mapping&quot;&gt;Table 5.1&lt;/a&gt;计划的，我们想要一个  /signup 的uri 来作为注册页面地址。在开始我们的改动之前，和 &lt;a href=&quot;filling-in-the-layout#sec-layout_links&quot;&gt;Section 5.3&lt;/a&gt;一样，我们首先要写一个测试，可以这样生成： &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rails generate integration_test user_pages
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后如同我们在 static 页面测试中所做的一样，我们将会写上测试代码来对 &lt;code&gt;h1&lt;/code&gt; 和  &lt;code&gt;title&lt;/code&gt; 标签进行测试，如下：&lt;/p&gt;

&lt;p&gt;Listing 5.31. The initial spec for users, with a test for the signup
page. \
&lt;code&gt;spec/requests/user_pages_spec.rb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;require &amp;#39;spec_helper&amp;#39;

describe &amp;quot;User pages&amp;quot; do

  subject { page }

  describe &amp;quot;signup page&amp;quot; do
    before { visit signup_path }

    it { should have_selector(&amp;#39;h1&amp;#39;,    text: &amp;#39;Sign up&amp;#39;) }
    it { should have_selector(&amp;#39;title&amp;#39;, text: full_title(&amp;#39;Sign up&amp;#39;)) }
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;rspec&lt;/code&gt; 来进行测试：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle exec rspec spec/requests/user_pages_spec.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还可以直接对目录下的所有文件进行测试：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle exec rspec spec/requests/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或许你也猜到了，你甚至可以这样运行所有的 specs 测试：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle exec rspec spec/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了测试的完整，我们将来可能常常会使用这条命令进行测试。顺便提一句，有的人喜欢用 rake task 来进行完整的测试，像这样&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle exec rake spec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;甚至他们只需要键入 &lt;code&gt;rake&lt;/code&gt; 就足够了，因为默认的rake行为就是运行测试套件。&lt;/p&gt;

&lt;p&gt;至今，我们的用户控制器已经有了一个 &lt;code&gt;new&lt;/code&gt; 行为，为了让我们的测试通过，我们需要写出正确的路由设置和视图内容。我们将会依据 &lt;a href=&quot;filling-in-the-layout#code-static_page_routes&quot;&gt;Listing 5.21&lt;/a&gt; 然后加入一行 &lt;code&gt;match ’/signup’&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;Listing 5.32. A route for the signup page. \
&lt;code&gt;config/routes.rb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;SampleApp::Application.routes.draw do
  get &amp;quot;users/new&amp;quot;

  root to: &amp;#39;static_pages#home&amp;#39;

  match &amp;#39;/signup&amp;#39;,  to: &amp;#39;users#new&amp;#39;

  match &amp;#39;/help&amp;#39;,    to: &amp;#39;static_pages#help&amp;#39;
  match &amp;#39;/about&amp;#39;,   to: &amp;#39;static_pages#about&amp;#39;
  match &amp;#39;/contact&amp;#39;, to: &amp;#39;static_pages#contact&amp;#39;
  .
  .
  .
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意到文件中已经存在了 &lt;code&gt;get &amp;quot;users/new&amp;quot;&lt;/code&gt; ，它由控制器的 generate 命令自动添加。虽然 &lt;code&gt;’users/new’&lt;/code&gt; 这样的地址现在已经可用，但是这并不符合我们的REST标准 (&lt;a href=&quot;a-demo-app#table-demo_RESTful_users&quot;&gt;Table 2.2&lt;/a&gt;)，我们将会在 &lt;a href=&quot;sign-up#sec-a_users_resource&quot;&gt;Section 7.1.2&lt;/a&gt;对其作出处理.&lt;/p&gt;

&lt;p&gt;为了让测试通过，我们所需要第一件事就是为视图文件添加一个 titile 和 “Sign up” 的头部标签：&lt;/p&gt;

&lt;p&gt;Listing 5.33. The initial (stub) signup page. \
&lt;code&gt;app/views/users/new.html.erb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;% provide(:title, &amp;#39;Sign up&amp;#39;) %&amp;gt;
&amp;lt;h1&amp;gt;Sign up&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;Find me in app/views/users/new.html.erb&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在 signup 的测试应该能够通过了，接下来的是给 Home 页面加入一个 button 。我们在路由文件中写入了  &lt;code&gt;match ’/signup’&lt;/code&gt;，这将生成一个叫  &lt;code&gt;signup_path&lt;/code&gt; 的路径helper，我们可以把它用上了：&lt;/p&gt;

&lt;p&gt;Listing 5.34. Linking the button to the Signup page. \
&lt;code&gt;app/views/static_pages/home.html.erb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;div class=&amp;quot;center hero-unit&amp;quot;&amp;gt;
  &amp;lt;h1&amp;gt;Welcome to the Sample App&amp;lt;/h1&amp;gt;

  &amp;lt;h2&amp;gt;
    This is the home page for the
    &amp;lt;a href=&amp;quot;http://railstutorial.org/&amp;quot;&amp;gt;Ruby on Rails Tutorial&amp;lt;/a&amp;gt;
    sample application.
  &amp;lt;/h2&amp;gt;

  &amp;lt;%= link_to &amp;quot;Sign up now!&amp;quot;, signup_path, class: &amp;quot;btn btn-large btn-primary&amp;quot; %&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;%= link_to image_tag(&amp;quot;rails.png&amp;quot;, alt: &amp;quot;Rails&amp;quot;), &amp;#39;http://rubyonrails.org/&amp;#39; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，我们已经暂时完成了所有的链接和命名路由的设置，最终结果如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/figures/new_signup_page_bootstrap.png&quot; alt=&quot;new\_signup\_page\_bootstrap&quot;&gt;&lt;/p&gt;

&lt;p&gt;Figure 5.9: The new signup page at
&lt;a href=&quot;http://localhost:3000/signup&quot;&gt;/signup&lt;/a&gt;. &lt;a href=&quot;http://railstutorial.org/images/figures/new_signup_page_bootstrap-full.png&quot;&gt;(full
size)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;此时应该能够通过所有的测试：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle exec rspec spec/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;a href=&quot;filling-in-the-layout#sec-layout_conclusion&quot;&gt;5.5 总结整理&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;在这一章中，我们对应用的布局和路由进行了修改。接下来，本书会渐渐地完善这一个简单的示例程序：用户可以在这样的程序中注册，登录，登出，发布微博，最后能够让用户互相关注。&lt;/p&gt;

&lt;p&gt;而现在，我们应该使用 Git 来把我们的成果合并到 master 分支上：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git add .
$ git commit -m &amp;quot;Finish layout and routes&amp;quot;
$ git checkout master
$ git merge filling-in-layout
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后push到Github上&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;部署&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git push heroku
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看自己的成果&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ heroku open
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果出错了，可以如下查看日志&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ heroku logs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并根据 heroku 的日志来进行 debug.&lt;/p&gt;
</description>
                <link>http://tutorial.railschina.org/rails%20%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B/2013/08/28/chapter-5</link>
                <guid>http://tutorial.railschina.org/rails%20%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B/2013/08/28/chapter-5</guid>
                <pubDate>2013-08-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>第四章 Rails中的Ruby</title>
                <description>&lt;p&gt;翻译 &lt;a href=&quot;http://ruby.railstutorial.org/chapters/a-demo-app#top&quot;&gt;ruby on rails Tutorial&lt;/a&gt;,原作者 &lt;a href=&quot;http://michaelhartl.com/&quot;&gt;Michael Hartl&lt;/a&gt; .&lt;/p&gt;

&lt;h2&gt;第四章 Rails 中的 Ruby&lt;/h2&gt;

&lt;p&gt;早在第三章的例子中，我们就已经介绍了一些 Rails 中用上的重要 Ruby 属性。Ruby 是一门博大精深的语言，庆幸的是，对于一个 Rails 开发者来说，你并不需要那么地精通。现在的做法或许和通常学习Ruby的方法有点相背，但是就我的建议来说：如果你的目标是写出一个完整的动态网站，那么你应该先学 Rails， 顺带学一学 Ruby，当你需要变成 Rails 专家的时候，你就需要更加深入地学习 Ruby了。而这本书将会为你打下良好的基础，如同我在 &lt;a href=&quot;http://ruby.railstutorial.org/chapters/beginning#sec-comments_for_various_readers&quot;&gt;章节1.1&lt;/a&gt; 当中所说，在完成了这部教程之后我建议能够认真地阅读一本纯粹的 Ruby 教程，例如 &lt;a href=&quot;http://www.amazon.com/gp/product/1430223634&quot;&gt;Beginning Ruby&lt;/a&gt;, &lt;a href=&quot;http://www.amazon.com/gp/product/1933988657&quot;&gt;The Well-Grounded Rubyist&lt;/a&gt;,或者 &lt;a href=&quot;http://www.amazon.com/gp/product/0672328844&quot;&gt;The Ruby Way&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;4.1 动机&lt;/h3&gt;

&lt;p&gt;正如我们上一章所看到的看，在不具备 Ruby 知识的情况下进行 Rails 应用程序开发，甚至开始测试是可能的。但是我们这样做是依靠本教程所提供的测试代码并处理每一个错误消息，这样反复修改直到经过测试。这种情况是不可能永远持续下去的。所以，现在，让我们打开本章的网站，与限制我们的 Ruby 语法来一次亲密接触。&lt;/p&gt;

&lt;p&gt;让我们再看一眼我们上次的程序，我们更新了几乎全静态的 Rails 布局文件，并用Rails消灭了我们视图中的重复部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Listing 4.1.&lt;/strong&gt;  示例应用布局
&lt;code&gt;app/views/layouts/application.html.erb&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Ruby on Rails Tutorial Sample App | &amp;lt;%= yield(:title) %&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;%= stylesheet_link_tag    &amp;quot;application&amp;quot;, :media =&amp;gt; &amp;quot;all&amp;quot; %&amp;gt;
    &amp;lt;%= javascript_include_tag &amp;quot;application&amp;quot; %&amp;gt;
    &amp;lt;%= csrf_meta_tags %&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;%= yield %&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let’s focus on one particular line in Listing 4.1:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;%= stylesheet_link_tag &amp;quot;application&amp;quot;, :media =&amp;gt; &amp;quot;all&amp;quot; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用的内建的 Rails 函数 &lt;code&gt;stylesheet_link_tag&lt;/code&gt;(关于它你可以在Rails API 中找到更多信息)来把 &lt;code&gt;application.css&lt;/code&gt; 的所有 &lt;em&gt;media types&lt;/em&gt;都饱含进来。对于已经富有经验的 Rails 开发者来说，这是一句再简单不过的语句。但是就是这一小小的语句中至少包含了四个足以令新手困惑不解的Ruby概念：无调用者的函数调用，符号，哈西，Rails内建函数。我们把这些概念贯穿在这一章之中。&lt;/p&gt;

&lt;p&gt;另外，Rails 已经内建了非常多的函数，并且，Rails 还允许我们建立新的函数，这些函数我们叫做 &lt;code&gt;Helpers&lt;/code&gt; ;要想见识怎么新建一个 helper。我们先看看我们在 Listing 4.1: 中看到的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;Ruby on Rails Tutorial Sample App | &amp;lt;%= yield(:title) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个语句依赖于我们在页面标题处的定义（使用了 &lt;em&gt;provide&lt;/em&gt; 函数）,例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;% provide(:title, &amp;#39;Home&amp;#39;) %&amp;gt;
&amp;lt;h1&amp;gt;Sample App&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;
  This is the home page for the
  &amp;lt;a href=&amp;quot;http://railstutorial.org/&amp;quot;&amp;gt;Ruby on Rails Tutorial&amp;lt;/a&amp;gt;
  sample application.
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么如果我们没有提供一个标题变量呢？这是一个很实用的小技巧，如果可以最好在每一个页面上写入一个基本标题。于是，在当前布局下，如果你没有提供一个可以传入 view 中的变量，那么一个空位就会产生，大致像这样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;Ruby on Rails Tutorial Sample App |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，就有了能适应所有网页的这一句话，但是在末尾还有一个讨厌的管道号字符。&lt;/p&gt;

&lt;p&gt;要想解决这个问题，我们定义了一个 Helper 函数叫作 full&lt;em&gt;title. full&lt;/em&gt;title helper 主要的功能就是返回一个基本的标题“Ruby on Rails Tutorial Sample App”，如果有指定的页面标题的话，就在这句话之后加入一个 管道号 之后再输出指定标题。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;module ApplicationHelper

  # Returns the full title on a per-page basis.
  def full_title(page_title)
    base_title = &amp;quot;Ruby on Rails Tutorial Sample App&amp;quot;
    if page_title.empty?
      base_title
    else
      &amp;quot;#{base_title} | #{page_title}&amp;quot;
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们可以把我们的布局文件上的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;title&amp;gt;Ruby on Rails Tutorial Sample App | &amp;lt;%= yield(:title) %&amp;gt;&amp;lt;/title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;换成：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;title&amp;gt;&amp;lt;%= full_title(yield(:title)) %&amp;gt;&amp;lt;/title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在是这样了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;%= full_title(yield(:title)) %&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;%= stylesheet_link_tag    &amp;quot;application&amp;quot;, :media =&amp;gt; &amp;quot;all&amp;quot; %&amp;gt;
    &amp;lt;%= javascript_include_tag &amp;quot;application&amp;quot; %&amp;gt;
    &amp;lt;%= csrf_meta_tags %&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;%= yield %&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要想我们的 helper 正常工作，我们需要把没必要的单词 “Home” 从首页中删除。这样让Helper 的标题能回到原来的状态。在这里我们先从测试文件做起。&lt;/p&gt;

&lt;p&gt;spec/requests/static&lt;em&gt;pages&lt;/em&gt;spec.rb
    require &amp;#39;spec_helper&amp;#39;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;describe &amp;quot;Static pages&amp;quot; do

  describe &amp;quot;Home page&amp;quot; do

    it &amp;quot;should have the h1 &amp;#39;Sample App&amp;#39;&amp;quot; do
      visit &amp;#39;/static_pages/home&amp;#39;
      page.should have_selector(&amp;#39;h1&amp;#39;, :text =&amp;gt; &amp;#39;Sample App&amp;#39;)
    end

    it &amp;quot;should have the base title&amp;quot; do
      visit &amp;#39;/static_pages/home&amp;#39;
      page.should have_selector(&amp;#39;title&amp;#39;,
                        :text =&amp;gt; &amp;quot;Ruby on Rails Tutorial Sample App&amp;quot;)
    end

    it &amp;quot;should not have a custom page title&amp;quot; do
      visit &amp;#39;/static_pages/home&amp;#39;
      page.should_not have_selector(&amp;#39;title&amp;#39;, :text =&amp;gt; &amp;#39;| Home&amp;#39;)
    end
  end
  .
  .
  .
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们来运行一下这个失败的测试文件。
    $ bundle exec rspec spec/requests/static&lt;em&gt;pages&lt;/em&gt;spec.rb
为了让这个测试能够通过，我们需要把对应行从“首页”视图中拿掉，像这样：
    &lt;h1&gt;Sample App&lt;/h1&gt;
    &lt;p&gt;
      This is the home page for the
      &lt;a href=&quot;http://railstutorial.org/&quot;&gt;Ruby on Rails Tutorial&lt;/a&gt;
      sample application.
    &lt;/p&gt;
修改之后的视图文件只包含一个 application css文件，这对于一个经验丰富的Rails开发者来说是再正常不过的事情，但是在这背后却有许多令人迷惑的Ruby难题：模块，注释，变量引用，bool变量，控制流，字符串解释器和返回值。这个章节会在下面对它们进行讲解。&lt;/p&gt;

&lt;h3&gt;4.2 字符串与方法&lt;/h3&gt;

&lt;p&gt;我们学习Ruby的主要工具将会是 Rails Console ，一个命令行的Rails解释器。这个解释器建立在Ruby自带的解释器之上（irb），它能够完全发挥出Ruby 和 Rails 的威力。开启一个Rails Console 只要这样&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rails console
Loading development environment
&amp;gt;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认情况下，这个命令行将会在开发模式下运行，开发模式是三种Rails预先定义好的运行模式之一（还有两种是测试模式和生产模式）.他们的区别并不是本章的重点，我们将会在第七章涉及到这些内容。&lt;/p&gt;

&lt;p&gt;命令行是一个非常棒的学习工具，你可以用它自由地浏览各类数据---别担心，你不会弄坏它的。当你实用命令行的时候，如果卡了就用 Ctrl-C 结束当前任务，或者用 Ctrl-D 退出命令行。在本章的剩余部分，你将会借助它发现Ruby API 的强大。如果需要，你可以上网查看Ruby 的api 文档。&lt;/p&gt;

&lt;h4&gt;4.2.1 注释&lt;/h4&gt;

&lt;p&gt;Ruby 的注释使用用一个井号开头 # 例如&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;# Returns the full title on a per-page basis.
  def full_title(page_title)
    .
    .
    .
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的第一行注释了接下来的函数作用。
在console中，你同样可以实用这个方法来注释。&lt;/p&gt;

&lt;p&gt;$ rails console&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;17 + 42   # Integer addition
=&amp;gt; 59&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;总之，Ruby将会忽略 # 之后的所有内容。&lt;/p&gt;

&lt;h4&gt;4.2.2 字符串&lt;/h4&gt;

&lt;p&gt;字符串可能是web应用程序中最重要的一部分了，因为网页通过互联网发送给浏览器的终究是一大串字符。让我们从命令行开始，领略一下Ruby神奇的处理文本的能力吧。这次我们从 &lt;code&gt;rails c&lt;/code&gt; 这个命令开始，这个命令是 &lt;code&gt;rails console&lt;/code&gt; 的简写&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rails c
&amp;gt;&amp;gt; &amp;quot;&amp;quot;         # An empty string
=&amp;gt; &amp;quot;&amp;quot;
&amp;gt;&amp;gt; &amp;quot;foo&amp;quot;      # A nonempty string
=&amp;gt; &amp;quot;foo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些变量叫做字面量，或者你可以蛋疼地叫它字面字符串，它们可以用双引号来创建。每当创建一个字面量命令行总会回显一次是因为字面量的值就是本身。&lt;/p&gt;

&lt;p&gt;我们可以用 &lt;code&gt;+&lt;/code&gt;  号来链接各个字面量&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; &amp;quot;foo&amp;quot; + &amp;quot;bar&amp;quot;    # String concatenation
=&amp;gt; &amp;quot;foobar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里看到 &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt; 加上&lt;code&gt;&amp;quot;bar&amp;quot;&lt;/code&gt; 输出了字符串&lt;code&gt;“foobar”&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;另外一个产生字符串的方法是实用特殊语法  &lt;code&gt;#{ }&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; first_name = &amp;quot;Michael&amp;quot;    # Variable assignment
=&amp;gt; &amp;quot;Michael&amp;quot;
&amp;gt;&amp;gt; &amp;quot;#{first_name} Hartl&amp;quot;     # String interpolation
=&amp;gt; &amp;quot;Michael Hartl&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里我们先定义了字符串变量 &amp;quot;Michael&amp;quot; 到 &lt;code&gt;first_name&lt;/code&gt; 然后在把这个变量在字符串中引用  &amp;quot;#{first_name} Hartl&amp;quot;，这样我们就可以在一个字符串中同时使用变量和字符串。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; first_name = &amp;quot;Michael&amp;quot;
=&amp;gt; &amp;quot;Michael&amp;quot;
&amp;gt;&amp;gt; last_name = &amp;quot;Hartl&amp;quot;
=&amp;gt; &amp;quot;Hartl&amp;quot;
&amp;gt;&amp;gt; first_name + &amp;quot; &amp;quot; + last_name    # Concatenation, with a space in between
=&amp;gt; &amp;quot;Michael Hartl&amp;quot;
&amp;gt;&amp;gt; &amp;quot;#{first_name} #{last_name}&amp;quot;    # The equivalent interpolation
=&amp;gt; &amp;quot;Michael Hartl&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主意最后两个表达式的值是相同的，但是我更倾向于后者，因为中间加上一个 “ ” 感觉优点怪怪的。&lt;/p&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;p&gt;要想输出一个字符串，在Ruby 中最常用的函数就是 puts 了，（念作  /put ess/ ,因为这其实是 &amp;#39;put string&amp;#39;的缩写）。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; puts &amp;quot;foo&amp;quot;     # put string
foo
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个 puts 方法却有一个副作用： 这个表达式在屏幕上输出 “foo” 之后却什么也不返回--- nil 是 Ruby 中 “什么都没有” 的意思。&lt;/p&gt;

&lt;p&gt;另外，如果实用了 puts 函数将会自动换行，即在行末尾加上 \n , 然而类似的函数 print 就不会这样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; print &amp;quot;foo&amp;quot;    # print string (same as puts, but without the newline)
foo=&amp;gt; nil
&amp;gt;&amp;gt; print &amp;quot;foo\n&amp;quot;  # Same as puts &amp;quot;foo&amp;quot;
foo
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;单引号字符串：&lt;/p&gt;

&lt;p&gt;至此我们实用的字符串都是双引号字符串，但是Ruby同样也支持单引号字符串。在使用上，这两种字符串基本一致：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; &amp;#39;foo&amp;#39;          # A single-quoted string
=&amp;gt; &amp;quot;foo&amp;quot;
&amp;gt;&amp;gt; &amp;#39;foo&amp;#39; + &amp;#39;bar&amp;#39;
=&amp;gt; &amp;quot;foobar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是他们确有一个非常重要的区别，就是: Ruby 不会在单引号是引用字符串变量：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; &amp;#39;#{foo} bar&amp;#39;     # Single-quoted strings don&amp;#39;t allow interpolation
=&amp;gt; &amp;quot;\#{foo} bar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意到这里的单引号中的变量引用失败了，其中的 # 号被加上的反斜杠表示这里的 # 号并不是一个注释号。&lt;/p&gt;

&lt;p&gt;但是既然双引号字符串可以做到任何单引号字符串可以做到的事情，和留着后者有什么用呢？这是因为单引号之中的字符串是一种“纯正的字符串”，其中包含的每一个字符都是字面量的一部分。例如，反斜杠字符对于许多系统来说都是一个特殊值，例如 \n 指的是换行符。如果你想要一个变量包含了换行符（而不是换行），那么单引号能将你的操作简化：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; &amp;#39;\n&amp;#39;       # A literal &amp;#39;backslash n&amp;#39; combination
=&amp;gt; &amp;quot;\\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样的道理，# 字符也是一个例子，Ruby 在建立这些字符串的时候将字符串额外作出 “逃脱转换”，在双引号中，一个字面上的反斜杠需要写成两个反斜杠 ，或许这并不能让你节省出什么，但是却让你摆脱此次更改增减反斜杠的烦恼：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; &amp;#39;Newlines (\n) and tabs (\t) both use the backslash character \.&amp;#39;
=&amp;gt; &amp;quot;Newlines (\\n) and tabs (\\t) both use the backslash character \\.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.2.3 对象与消息传送&lt;/h4&gt;

&lt;p&gt;Ruby中的所有东西，包括字符串乃至nil，都是一个对象，我们会在4.4.2节更加详细地接触到这个概念，但是没有人能够轻易地就从书中学到面向对象，你需要通过阅读更多的例子和代码才能够理解这个概念。&lt;/p&gt;

&lt;p&gt;对象会对消息作出反映，一个对象，例如字符串，可以响应“长度”这个消息，它将会返回字符串的长度信息。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; &amp;quot;foobar&amp;quot;.length        # Passing the &amp;quot;length&amp;quot; message to a string
=&amp;gt; 6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常来说，传给对象的会是一个方法，这些方法在对象中被定义。字符串也可以对 &lt;code&gt;empty?&lt;/code&gt; 方法作出响应：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; &amp;quot;foobar&amp;quot;.empty?
=&amp;gt; false
&amp;gt;&amp;gt; &amp;quot;&amp;quot;.empty?
=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到 &lt;code&gt;empty?&lt;/code&gt; 中的那个问好了么。这在 Ruby 中说明这个方法将会返回一个boolean型变量： true 或者 false .  Boolean 变量在控制流中很常见:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; s = &amp;quot;foobar&amp;quot;
&amp;gt;&amp;gt; if s.empty?
&amp;gt;&amp;gt;   &amp;quot;The string is empty&amp;quot;
&amp;gt;&amp;gt; else
&amp;gt;&amp;gt;   &amp;quot;The string is nonempty&amp;quot;
&amp;gt;&amp;gt; end
=&amp;gt; &amp;quot;The string is nonempty&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Boolean 变量可以通过 &amp;amp;&amp;amp;(且)， ||（或）， !（非） 进行操作：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; x = &amp;quot;foo&amp;quot;
=&amp;gt; &amp;quot;foo&amp;quot;
&amp;gt;&amp;gt; y = &amp;quot;&amp;quot;
=&amp;gt; &amp;quot;&amp;quot;
&amp;gt;&amp;gt; puts &amp;quot;Both strings are empty&amp;quot; if x.empty? &amp;amp;&amp;amp; y.empty?
=&amp;gt; nil
&amp;gt;&amp;gt; puts &amp;quot;One of the strings is empty&amp;quot; if x.empty? || y.empty?
&amp;quot;One of the strings is empty&amp;quot;
=&amp;gt; nil
&amp;gt;&amp;gt; puts &amp;quot;x is not empty&amp;quot; if !x.empty?
&amp;quot;x is not empty&amp;quot;
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为在Ruby 中一切都是对象，所以&lt;code&gt;nil&lt;/code&gt;也是一个对象，它同样也可以对方法作出响应。一个例子是你可以用 &lt;code&gt;to_s&lt;/code&gt; 方法把nil显式地转换成一个空字符串. &lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;nil.to_s
=&amp;gt; &amp;quot;&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;结果显然是一个空的字符串，我们把传送给对象的消息给链接起来：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; nil.empty?
NoMethodError: You have a nil object when you didn&amp;#39;t expect it!
You might have expected an instance of Array.
The error occurred while evaluating nil.empty?
&amp;gt;&amp;gt; nil.to_s.empty?      # Message chaining
=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们看到 nil 对象本身并响应 &lt;code&gt;empty?&lt;/code&gt; 方法，但是 &lt;code&gt;nil.to_s&lt;/code&gt; 却可以。&lt;/p&gt;

&lt;p&gt;下面这个是一个特殊的函数，用来判断对象是否是 &lt;code&gt;nil&lt;/code&gt; 结果是什么你可以猜到：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; &amp;quot;foo&amp;quot;.nil?
=&amp;gt; false
&amp;gt;&amp;gt; &amp;quot;&amp;quot;.nil?
=&amp;gt; false
&amp;gt;&amp;gt; nil.nil?
=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的代码会在 &lt;code&gt;!x.empty?&lt;/code&gt; 输出 &amp;#39;x 非空&amp;#39; ,在 Ruby 中，你可以用 if 语句来进行控制，只有在 if 之后的表达的值为true的时候对应语句才会执行。
而 unless 语句与 if 相互补，会在表达式的值为 false 的时候执行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; string = &amp;quot;foobar&amp;quot;
&amp;gt;&amp;gt; puts &amp;quot;The string &amp;#39;#{string}&amp;#39; is nonempty.&amp;quot; unless string.empty?
The string &amp;#39;foobar&amp;#39; is nonempty.
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要注意的事，nil对象十分的特殊，因为在Ruby中，除了 false本身，nil是唯一的值为 false 的对象。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; if nil
&amp;gt;&amp;gt;   true
&amp;gt;&amp;gt; else
&amp;gt;&amp;gt;   false        # nil is false
&amp;gt;&amp;gt; end
=&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了false和nil，其他的一切都是true，甚至是 0:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;if 0
  true        # 0 (and everything other than nil and false itself) is true
else
  false
end
=&amp;gt; true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h4&gt;4.2.4 函数定义&lt;/h4&gt;

&lt;p&gt;在命令行中，我们可以像 3.6 中一样定义函数。我们来定义一个 &lt;code&gt;string_message&lt;/code&gt; 方法来返回这个对象是否为空：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; def string_message(string)
&amp;gt;&amp;gt;   if string.empty?
&amp;gt;&amp;gt;     &amp;quot;It&amp;#39;s an empty string!&amp;quot;
&amp;gt;&amp;gt;   else
&amp;gt;&amp;gt;     &amp;quot;The string is nonempty.&amp;quot;
&amp;gt;&amp;gt;   end
&amp;gt;&amp;gt; end
=&amp;gt; nil
&amp;gt;&amp;gt; puts string_message(&amp;quot;&amp;quot;)
It&amp;#39;s an empty string!
&amp;gt;&amp;gt; puts string_message(&amp;quot;foobar&amp;quot;)
The string is nonempty.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ruby 函数有着隐形的返回值，它将把最后确定的表达式值作为返回值返回。因此，在这里显示哪一个字符串，取决于字符串是否为空。Ruby 也有一个显性的返回值，例如：    &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; def string_message(string)
&amp;gt;&amp;gt;   return &amp;quot;It&amp;#39;s an empty string!&amp;quot; if string.empty?
&amp;gt;&amp;gt;   return &amp;quot;The string is nonempty.&amp;quot;
&amp;gt;&amp;gt; end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，其实第二个return是没有必要的。因为运行至此处该语句已经是函数的末尾，不管如何，字符串 &amp;quot;The string is nonempty.&amp;quot; 都将作为函数的返回值返回。&lt;/p&gt;

&lt;h4&gt;4.2.5 回到 title 的helper 方法上&lt;/h4&gt;

&lt;p&gt;现在我们已经足以理解 4.2 中的helper方法了&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;module ApplicationHelper

  # Returns the full title on a per-page basis.       # Documentation comment
  def full_title(page_title)                          # Method definition
    base_title = &amp;quot;Ruby on Rails Tutorial Sample App&amp;quot;  # Variable assignment
    if page_title.empty?                              # Boolean test
      base_title                                      # Implicit return
    else
      &amp;quot;#{base_title} | #{page_title}&amp;quot;                 # String interpolation
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;元素定义，函数定义，变量引用，控制语句，bool值，字符串的引用变量，这些技巧综合在一起，就造成了我们站点中的layout。唯一我们还不明白的是开头的模块： &lt;code&gt;ApplicationHelper&lt;/code&gt; : 模块能够将相关的方法组合起来，并且还以在Ruby的类中通过 &lt;code&gt;include&lt;/code&gt; 方法 &lt;code&gt;mixed in&lt;/code&gt; 。当你从头写一个Ruby类的时候，你需要自己引用并整理好类和模块，但是在Rails Helper 中，你不需要做这么多，因为 &lt;code&gt;full_title&lt;/code&gt; 会被 Rails 自动处理，你直接就可以在视图中使用。 &lt;/p&gt;

&lt;p&gt;4.3 其他数据结构&lt;/p&gt;

&lt;p&gt;虽然web应用最终通常都是字符串，但是在组成这些字符串的时候我们常常需要用到其他的一些数据结构。这里我们学习一些Rails 应用中常用的Ruby数据结构。&lt;/p&gt;

&lt;p&gt;4.3.1 Array &amp;amp; Range&lt;/p&gt;

&lt;p&gt;一个数组就是一组有序元素的组合。虽然我们还没有仔细讨论过数组，但是数组作为一个基本结构将会让你更好地理解后面的Hash数据结构和Rails数据模型。&lt;/p&gt;

&lt;p&gt;至今我们已经花了一点时间理解字符串，那么我们从一个简单的方法开始，把字符串用 &lt;code&gt;split&lt;/code&gt; 函数转换为数组：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt;  &amp;quot;foo bar     baz&amp;quot;.split     # Split a string into a three-element array
=&amp;gt; [&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;操作的结果是包含三个字符串的数据，默认情况下，&lt;code&gt;split&lt;/code&gt; 将会通过空格把一个字符串中的单词拆开，但是你可以指定其他的字符来作为分隔符：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; &amp;quot;fooxbarxbazx&amp;quot;.split(&amp;#39;x&amp;#39;)
=&amp;gt; [&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;沿用了计算机的传统，Ruby 的数据从 0 下标开始，着意味着数组是从0下标开始计数，第二个数下标为1:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; a = [42, 8, 17]
=&amp;gt; [42, 8, 17]
&amp;gt;&amp;gt; a[0]               # Ruby uses square brackets for array access.
=&amp;gt; 42
&amp;gt;&amp;gt; a[1]
=&amp;gt; 8
&amp;gt;&amp;gt; a[2]
=&amp;gt; 17
&amp;gt;&amp;gt; a[-1]              # Indices can even be negative!
=&amp;gt; 17
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ruby 中实用方括号对数组元素定位，对于一些位置特殊的元素，Ruby还有一些其他的方法可以定位：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; a                  # Just a reminder of what &amp;#39;a&amp;#39; is
=&amp;gt; [42, 8, 17]
&amp;gt;&amp;gt; a.first
=&amp;gt; 42
&amp;gt;&amp;gt; a.second
=&amp;gt; 8
&amp;gt;&amp;gt; a.last
=&amp;gt; 17
&amp;gt;&amp;gt; a.last == a[-1]    # Comparison using ==
=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后一行里用到了相等比较操作 == ，和其他语言一样，与 != 相反：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; x = a.length       # Like strings, arrays respond to the &amp;#39;length&amp;#39; method.
=&amp;gt; 3
&amp;gt;&amp;gt; x == 3
=&amp;gt; true
&amp;gt;&amp;gt; x == 1
=&amp;gt; false
&amp;gt;&amp;gt; x != 1
=&amp;gt; true
&amp;gt;&amp;gt; x &amp;gt;= 1
=&amp;gt; true
&amp;gt;&amp;gt; x &amp;lt; 1
=&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外， Ruby 的数组对象还定义了很多实用的方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; a
=&amp;gt; [42, 8, 17]
&amp;gt;&amp;gt; a.sort
=&amp;gt; [8, 17, 42]
&amp;gt;&amp;gt; a.reverse
=&amp;gt; [17, 8, 42]
&amp;gt;&amp;gt; a.shuffle
=&amp;gt; [17, 42, 8]
&amp;gt;&amp;gt; a
=&amp;gt; [42, 8, 17]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你发现了么，这里方法的调用并没有更改数组本身，若要改变数组本身，你可以使用相关的方法加上感叹号：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; a
=&amp;gt; [42, 8, 17]
&amp;gt;&amp;gt; a.sort!
=&amp;gt; [8, 17, 42]
&amp;gt;&amp;gt; a
=&amp;gt; [8, 17, 42]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用push方法或者 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 操作符号对数组添加元素：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; a.push(6)                  # Pushing 6 onto an array
=&amp;gt; [42, 8, 17, 6]
&amp;gt;&amp;gt; a &amp;lt;&amp;lt; 7                     # Pushing 7 onto an array
=&amp;gt; [42, 8, 17, 6, 7]
&amp;gt;&amp;gt; a &amp;lt;&amp;lt; &amp;quot;foo&amp;quot; &amp;lt;&amp;lt; &amp;quot;bar&amp;quot;        # Chaining array pushes
=&amp;gt; [42, 8, 17, 6, 7, &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后一个例子里，我们把push方法连了起来，另外，你也发现了Ruby和其他语言的不同之处，在数组中可以存放不同类型的东西。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;split&lt;/code&gt;能将字符串拆成数组，相反地我们可以使用 &lt;code&gt;join&lt;/code&gt; 方法把数组组成字符串：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;=&amp;gt; &amp;quot;428177foobar&amp;quot;
&amp;gt;&amp;gt; a.join(&amp;#39;, &amp;#39;)                 # Join on comma-space
=&amp;gt; &amp;quot;42, 8, 17, 7, foo, bar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与数组很近似的是Range,它可以被 &lt;code&gt;to_a&lt;/code&gt;函数转换成数组。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; 0..9
=&amp;gt; 0..9
&amp;gt;&amp;gt; 0..9.to_a              # Oops, call to_a on 9
NoMethodError: undefined method `to_a&amp;#39; for 9:Fixnum
&amp;gt;&amp;gt; (0..9).to_a            # Use parentheses to call to_a on the range
=&amp;gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然 &lt;code&gt;0..9&lt;/code&gt; 是一个合法的 range 但是第二个表达式提醒我们在对其调用函数之前要加上括号。&lt;/p&gt;

&lt;p&gt;Range 在输出数组元素的时候相当的有用。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; a = %w[foo bar baz quux]         # Use %w to make a string array.
=&amp;gt; [&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;, &amp;quot;quux&amp;quot;]
&amp;gt;&amp;gt; a[0..2]
=&amp;gt; [&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Range 对字符也是有效的:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; (&amp;#39;a&amp;#39;..&amp;#39;e&amp;#39;).to_a
=&amp;gt; [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.3.2 代码块&lt;/p&gt;

&lt;p&gt;数组和range都可以用一些方法来接受代码块参数，这里的内容是 Ruby 最为强大的功能也是一个最为让人迷惑的特性。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; (1..5).each { |i| puts 2 * i }
2
4
6
8
10
=&amp;gt; 1..5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这份代码将会对 range (1..5) 中的每个元素传送代码块中的消息  { |i| puts 2 * i } 。其中用竖线包围起来的变量名 |i| 就是代码块变量，它决定了代码块中处理的对象。在这里，range 的each方法可以对代码块中的一个本地变量作出响应，我们把它叫做 i ，i 将以range中的内容依次执行代码块中内容。&lt;/p&gt;

&lt;p&gt;尖括号是实现代码块的一种方式，还有第二种方式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; (1..5).each do |i|
?&amp;gt;   puts 2 * i
&amp;gt;&amp;gt; end
2
4
6
8
10
=&amp;gt; 1..5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码块通常是多于一行的。在这份 Rails 教程中，我们将会遵循这一简单的原则：当代码块只有一行的时候我们使用尖括号代码块，如果超过一行的时候我们使用do..end 语法实现代码块：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; (1..5).each do |number|
?&amp;gt;   puts 2 * number
&amp;gt;&amp;gt;   puts &amp;#39;--&amp;#39;
&amp;gt;&amp;gt; end
2
--
4
--
6
--
8
--
10
--
=&amp;gt; 1..5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里我用 number 替换了 i ，只是想说明你可以使用任何变量名。    &lt;/p&gt;

&lt;p&gt;Unless you already have a substantial programming background, there is no shortcut to understanding blocks; you just have to see them a lot, and eventually you’ll get used to them.7 Luckily, humans are quite good at making generalizations from concrete examples; here are a few more, including a couple using the map method:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; 3.times { puts &amp;quot;Betelgeuse!&amp;quot; }   # 3.times takes a block with no variables.
&amp;quot;Betelgeuse!&amp;quot;
&amp;quot;Betelgeuse!&amp;quot;
&amp;quot;Betelgeuse!&amp;quot;
=&amp;gt; 3
&amp;gt;&amp;gt; (1..5).map { |i| i**2 }          # The ** notation is for &amp;#39;power&amp;#39;.
=&amp;gt; [1, 4, 9, 16, 25]
&amp;gt;&amp;gt; %w[a b c]                        # Recall that %w makes string arrays.
=&amp;gt; [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]
&amp;gt;&amp;gt; %w[a b c].map { |char| char.upcase }
=&amp;gt; [&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;]
&amp;gt;&amp;gt; %w[A B C].map { |char| char.downcase }
=&amp;gt; [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如你所见，map 方法将会把返回的结果替换数组或者range中的响应元素。&lt;/p&gt;

&lt;p&gt;现在，我们可以解释我在 1.4.4 生成随机字符串的Ruby语句了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;(&amp;#39;a&amp;#39;..&amp;#39;z&amp;#39;).to_a.shuffle[0..7].join
#让我们一步一步来

&amp;gt;&amp;gt; (&amp;#39;a&amp;#39;..&amp;#39;z&amp;#39;).to_a                     # An alphabet array
=&amp;gt; [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;g&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;j&amp;quot;, &amp;quot;k&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;n&amp;quot;, &amp;quot;o&amp;quot;,
&amp;quot;p&amp;quot;, &amp;quot;q&amp;quot;, &amp;quot;r&amp;quot;, &amp;quot;s&amp;quot;, &amp;quot;t&amp;quot;, &amp;quot;u&amp;quot;, &amp;quot;v&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;z&amp;quot;]
&amp;gt;&amp;gt; (&amp;#39;a&amp;#39;..&amp;#39;z&amp;#39;).to_a.shuffle             # Shuffle it.
=&amp;gt; [&amp;quot;c&amp;quot;, &amp;quot;g&amp;quot;, &amp;quot;l&amp;quot;, &amp;quot;k&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;z&amp;quot;, &amp;quot;s&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;n&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;u&amp;quot;, &amp;quot;t&amp;quot;, &amp;quot;j&amp;quot;, &amp;quot;q&amp;quot;,
&amp;quot;b&amp;quot;, &amp;quot;r&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;v&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;x&amp;quot;, &amp;quot;p&amp;quot;]
&amp;gt;&amp;gt; (&amp;#39;a&amp;#39;..&amp;#39;z&amp;#39;).to_a.shuffle[0..7]       # Pull out the first eight elements.
=&amp;gt; [&amp;quot;f&amp;quot;, &amp;quot;w&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;p&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;x&amp;quot;]
&amp;gt;&amp;gt; (&amp;#39;a&amp;#39;..&amp;#39;z&amp;#39;).to_a.shuffle[0..7].join  # Join them together to make one string.
=&amp;gt; &amp;quot;mznpybuj&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.3.3 哈希和符号&lt;/p&gt;

&lt;p&gt;哈希是一种更高层次的数组：你可以把哈希堪称一种数组，但是它不仅可以用数字作为索引（事实上，有一些语言，例如Perl，就把哈希叫做关联数组），而且可以用任何对象作为索引，我们也罢索引叫做键。例如我们可以把一串字符串当作键：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; user = {}                          # {} is an empty hash.
=&amp;gt; {}
&amp;gt;&amp;gt; user[&amp;quot;first_name&amp;quot;] = &amp;quot;Michael&amp;quot;     # Key &amp;quot;first_name&amp;quot;, value &amp;quot;Michael&amp;quot;
=&amp;gt; &amp;quot;Michael&amp;quot;
&amp;gt;&amp;gt; user[&amp;quot;last_name&amp;quot;] = &amp;quot;Hartl&amp;quot;        # Key &amp;quot;last_name&amp;quot;, value &amp;quot;Hartl&amp;quot;
=&amp;gt; &amp;quot;Hartl&amp;quot;
&amp;gt;&amp;gt; user[&amp;quot;first_name&amp;quot;]                 # Element access is like arrays.
=&amp;gt; &amp;quot;Michael&amp;quot;
&amp;gt;&amp;gt; user                               # A literal representation of the hash
=&amp;gt; {&amp;quot;last_name&amp;quot;=&amp;gt;&amp;quot;Hartl&amp;quot;, &amp;quot;first_name&amp;quot;=&amp;gt;&amp;quot;Michael&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哈希用尖括号把键值对包含起来；而一对尖括号意味着没有任何键值对，例如，｛｝就是一个空的哈希，大家在这里要注意区分尖括号生成的block和哈希的区别。虽然哈希和数组很类似，但是一个巨大的区别就是哈希是无序的。所以如果你想要维护一个有序的结构，那么请使用数组。&lt;/p&gt;

&lt;p&gt;相对于数组的用方括号来定义元素的方法，哈希的定义与引用都是很简单的，用 &amp;quot;=&amp;gt;&amp;quot; ———— 宇宙飞船符(hashrocket)把键值联系起来。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; user = { &amp;quot;first_name&amp;quot; =&amp;gt; &amp;quot;Michael&amp;quot;, &amp;quot;last_name&amp;quot; =&amp;gt; &amp;quot;Hartl&amp;quot; }
=&amp;gt; {&amp;quot;last_name&amp;quot;=&amp;gt;&amp;quot;Hartl&amp;quot;, &amp;quot;first_name&amp;quot;=&amp;gt;&amp;quot;Michael&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里我们在Ruby的哈希表达式的两端都加入了空格，这会在输出中被忽略（加上空格只是为了好看……）。&lt;/p&gt;

&lt;p&gt;现在我们已经用上字符串中作为键了，但是在Ruby on Rails 中，更为常见的键值类型是 “符号” 。符号看起来和字符串没什么两样，但是需要加上一个前缀 &lt;code&gt;:&lt;/code&gt; 而不是用双括号括起来。例如 :name 是一个符号。你可以认为符号就是一种简化的字符串 :9&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; &amp;quot;name&amp;quot;.split(&amp;#39;&amp;#39;)
=&amp;gt; [&amp;quot;n&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;m&amp;quot;, &amp;quot;e&amp;quot;]
&amp;gt;&amp;gt; :name.split(&amp;#39;&amp;#39;)
NoMethodError: undefined method `split&amp;#39; for :name:Symbol
&amp;gt;&amp;gt; &amp;quot;foobar&amp;quot;.reverse
=&amp;gt; &amp;quot;raboof&amp;quot;
&amp;gt;&amp;gt; :foobar.reverse
NoMethodError: undefined method `reverse&amp;#39; for :foobar:Symbol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相对于其他语言来说，符号是一种特殊的Ruby数据类型，所以他们在刚开始会显得很奇怪，但是当你Rails用得多了，你就会习惯他们并越用越快。&lt;/p&gt;

&lt;p&gt;回到符号作为哈希键上，我们可以定义一个用户哈希作为关注者，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; user = { :name =&amp;gt; &amp;quot;Michael Hartl&amp;quot;, :email =&amp;gt; &amp;quot;michael@example.com&amp;quot; }
=&amp;gt; {:name=&amp;gt;&amp;quot;Michael Hartl&amp;quot;, :email=&amp;gt;&amp;quot;michael@example.com&amp;quot;}
&amp;gt;&amp;gt; user[:name]              # Access the value corresponding to :name.
=&amp;gt; &amp;quot;Michael Hartl&amp;quot;
&amp;gt;&amp;gt; user[:password]          # Access the value of an undefined key.
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后一个例子我们看到了如果访问一个未定义键结果将是 nil.&lt;/p&gt;

&lt;p&gt;因为符号与哈希在Ruby中太常用了，Ruby1.9 支持了一种新用法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; h1 = { :name =&amp;gt; &amp;quot;Michael Hartl&amp;quot;, :email =&amp;gt; &amp;quot;michael@example.com&amp;quot; }
=&amp;gt; {:name=&amp;gt;&amp;quot;Michael Hartl&amp;quot;, :email=&amp;gt;&amp;quot;michael@example.com&amp;quot;}
&amp;gt;&amp;gt; h2 = { name: &amp;quot;Michael Hartl&amp;quot;, email: &amp;quot;michael@example.com&amp;quot; }
=&amp;gt; {:name=&amp;gt;&amp;quot;Michael Hartl&amp;quot;, :email=&amp;gt;&amp;quot;michael@example.com&amp;quot;} 
&amp;gt;&amp;gt; h1 == h2
=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这种语法中，符号和太空船符被key+引号+值代替了。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;{ name: &amp;quot;Michael Hartl&amp;quot;, email: &amp;quot;michael@example.com&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的结构就和一些其他语言类似了（例如Javascript），在Rails社区中也变得越来越流行。现在，两种语法都有着有着非常普遍的应用，在本书中，绝大部分会使用新的语法结构，而这个新语法对于1.8.7或之前的Ruby版本是非法的。因此，（如果你是Ruby 1.8 之前的版本）你最好把你的Ruby升级到1.9，或者你在自己的代码中实用旧的语法。&lt;/p&gt;

&lt;p&gt;哈希值是什么都可以，甚至哈希。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;#Listing 4.6. Nested hashes.
&amp;gt;&amp;gt; params = {}        # Define a hash called &amp;#39;params&amp;#39; (short for &amp;#39;parameters&amp;#39;).
=&amp;gt; {}
&amp;gt;&amp;gt; params[:user] = { name: &amp;quot;Michael Hartl&amp;quot;, email: &amp;quot;mhartl@example.com&amp;quot; }
=&amp;gt; {:name=&amp;gt;&amp;quot;Michael Hartl&amp;quot;, :email=&amp;gt;&amp;quot;mhartl@example.com&amp;quot;}
&amp;gt;&amp;gt; params
=&amp;gt; {:user=&amp;gt;{:name=&amp;gt;&amp;quot;Michael Hartl&amp;quot;, :email=&amp;gt;&amp;quot;mhartl@example.com&amp;quot;}}
&amp;gt;&amp;gt;  params[:user][:email]
=&amp;gt; &amp;quot;mhartl@example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以称它做哈希的哈希或者嵌套哈希，它在Rails中被广泛实用，我们在 7.3 将会见识到它。&lt;/p&gt;

&lt;p&gt;和数组和Range类一样，哈希能够响应 each 方法，例如，一个叫 flash 的哈希有两对键值，:success 和 :error:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; flash = { success: &amp;quot;It worked!&amp;quot;, error: &amp;quot;It failed.&amp;quot; }
=&amp;gt; {:success=&amp;gt;&amp;quot;It worked!&amp;quot;, :error=&amp;gt;&amp;quot;It failed.&amp;quot;}
&amp;gt;&amp;gt; flash.each do |key, value|
?&amp;gt;   puts &amp;quot;Key #{key.inspect} has value #{value.inspect}&amp;quot;
&amp;gt;&amp;gt; end
Key :success has value &amp;quot;It worked!&amp;quot;
Key :error has value &amp;quot;It failed.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，each方法的代码块对于数组来说只用一个变量，但是对于哈希来说就需要两个，一个是键，一个是值。因此，对于each方法来说，每次迭代会处理哈希中的一个键值对。&lt;/p&gt;

&lt;p&gt;最后一个例子，我们介绍十分有用的函数：inspect，它能够返回对象的文字描述：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; puts (1..5).to_a            # Put an array as a string.
1
2
3
4
5
&amp;gt;&amp;gt; puts (1..5).to_a.inspect    # Put a literal array.
[1, 2, 3, 4, 5]
&amp;gt;&amp;gt; puts :name, :name.inspect
name
:name
&amp;gt;&amp;gt; puts &amp;quot;It worked!&amp;quot;, &amp;quot;It worked!&amp;quot;.inspect
It worked!
&amp;quot;It worked!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于inspect太好用了，所以该方法有一个简写的 p 方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; p :name             # Same as &amp;#39;puts :name.inspect&amp;#39;
:name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.3.4 CSS 再加工&lt;/p&gt;

&lt;p&gt;是时候让我们回头看看过去在layout中写的层叠样式表了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;%= stylesheet_link_tag &amp;quot;application&amp;quot;, :media =&amp;gt; &amp;quot;all&amp;quot; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们已经彻底明白了这句话中的含义。正如我们在4.1中所解释的那样，Rails定义了一个特殊的函数用来包含样式表而通过&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;stylesheet_link_tag &amp;quot;application&amp;quot;, :media =&amp;gt; &amp;quot;all&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来调用这个函数。但是他们还是太神奇了，方法的圆括号呢？在Ruby中，圆括号是可选的，下面这两句表达式是相等的:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;# Parentheses on function calls are optional.
stylesheet_link_tag(&amp;quot;application&amp;quot;, :media =&amp;gt; &amp;quot;all&amp;quot;)
stylesheet_link_tag &amp;quot;application&amp;quot;, :media =&amp;gt; &amp;quot;all&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其次，:media 参数看起来好像一个哈希，但是他们的尖括号呢？事实上，当哈希作为函数的最后一个参数时，尖括号也是可选的，下面这两行是相等的:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;# Curly braces on final hash arguments are optional.
stylesheet_link_tag &amp;quot;application&amp;quot;, { :media =&amp;gt; &amp;quot;all&amp;quot; }
stylesheet_link_tag &amp;quot;application&amp;quot;, :media =&amp;gt; &amp;quot;all&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以当我们看到下面这一样的时候&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;stylesheet_link_tag &amp;quot;application&amp;quot;, :media =&amp;gt; &amp;quot;all&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它调用了&lt;code&gt;stylesheet_link_tag&lt;/code&gt;  函数，传递了两个参数：一个是字符串，指定了样式表的路径，另一个是哈希，指定了媒体的链接类型。因为有 &amp;lt;%= %&amp;gt; 括号，它产生的结果将被转换至 ERB template.如果你看了浏览器上的代码的话，你会发现最后生成了这样的语句.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;link href=&amp;quot;/assets/application.css&amp;quot; media=&amp;quot;all&amp;quot; rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你手动地访问服务器上的样式表文件，你将会看到这是一个空文件，别着急，我们将会在第五章对他进行完善。&lt;/p&gt;

&lt;p&gt;4.4 Ruby 类&lt;/p&gt;

&lt;p&gt;我们在之前说过了在Ruby中什么都是对象，在这一章的末尾我们将要自己下一点定义了。Ruby，和所有面向对象语言一样，使用类来组织方法，这些类能够创造对象。如果你是一个面向对象编程的新手，这听起来有点抽象，但是让我们看点具体的例子：&lt;/p&gt;

&lt;p&gt;4.4.1 实现&lt;/p&gt;

&lt;p&gt;我们已经见过很多类生成对象的例子，而且我们还做过。例如，当我们实用双引号的时候，将会产生一个字符串结构：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; s = &amp;quot;foobar&amp;quot;       # A literal constructor for strings using double quotes
=&amp;gt; &amp;quot;foobar&amp;quot;
&amp;gt;&amp;gt; s.class
=&amp;gt; String
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看到这里字符串响应了method类，并且返回了字符串对象所属的类。&lt;/p&gt;

&lt;p&gt;事实上我们可以使用另一种方法生成字符串:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;s = String.new(&amp;quot;foobar&amp;quot;)   # A named constructor for a string
=&amp;gt; &amp;quot;foobar&amp;quot;
s.class
=&amp;gt; String
s == &amp;quot;foobar&amp;quot;
=&amp;gt; true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实这两种方法结果都是一样的，但是这样能把意图表现的更加明确。&lt;/p&gt;

&lt;p&gt;数组中也是一样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; a = Array.new([1, 3, 2])
=&amp;gt; [1, 3, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哈希，相对来说有些变化。Array.new 根据参数初始化一个数组，而 Hash.new 根据参数生成所有未定义的键的值：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; h = Hash.new
=&amp;gt; {}
&amp;gt;&amp;gt; h[:foo]            # Try to access the value for the nonexistent key :foo.
=&amp;gt; nil
&amp;gt;&amp;gt; h = Hash.new(0)    # Arrange for nonexistent keys to return 0 instead of nil.
=&amp;gt; {}
&amp;gt;&amp;gt; h[:foo]
=&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当一个函数在类中被调用，例如这里的 new 方法，将被称为类函数。在一个类对象中调用new函数的结果是生成一个对象而响应对象是这个类的实例。而一个实例被函数调用的话，例如length，将会调用类中的实例函数.&lt;/p&gt;

&lt;p&gt;4.4.2 类与继承&lt;/p&gt;

&lt;p&gt;既然我们学到了类，我们不妨尝试学着用 ssuperclass 找到该类的上级类：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; s = String.new(&amp;quot;foobar&amp;quot;)
=&amp;gt; &amp;quot;foobar&amp;quot;
&amp;gt;&amp;gt; s.class                        # Find the class of s.
=&amp;gt; String
&amp;gt;&amp;gt; s.class.superclass             # Find the superclass of String.
=&amp;gt; Object
&amp;gt;&amp;gt; s.class.superclass.superclass  # Ruby 1.9 uses a new BasicObject base class
=&amp;gt; BasicObject 
&amp;gt;&amp;gt; s.class.superclass.superclass.superclass
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里是一份类与继承的表格，我们可以看到，String的父类是Object，而Object的父类是BasicObject,但是BasicObject没有父类。这份表格对于任何Ruby对象优势有效的。当若干次地查看对象的父类，任何一个Ruby类都将指向BasicObject。这也是为什么我们说&amp;quot;任何Ruby中的元素都是对象&amp;quot;的原因。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/string_inheritance_ruby_1_9.png&quot; alt=&quot;superclass&quot;&gt;&lt;/p&gt;

&lt;p&gt;要更深入地理解类，没有什么办法比自己动手更棒了。我们先来构建一个具有 palindrome? 函数的 Word 类，该函数将会判断指定单词是否为回文。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; class Word
&amp;gt;&amp;gt;   def palindrome?(string)
&amp;gt;&amp;gt;     string == string.reverse
&amp;gt;&amp;gt;   end
&amp;gt;&amp;gt; end
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以这么使用它：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; w = Word.new              # Make a new Word object.
=&amp;gt; #&amp;lt;Word:0x22d0b20&amp;gt;
&amp;gt;&amp;gt; w.palindrome?(&amp;quot;foobar&amp;quot;)
=&amp;gt; false
&amp;gt;&amp;gt; w.palindrome?(&amp;quot;level&amp;quot;)
=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子似乎已经让你有了一点灵感了不是么？但是现在我们的Word类有一点奇怪，我们只是需要判断一下回文却需要让类的函数带上一个字符串参数。因为单词本身就是一个字符串类，所以我们让Word类继承自String似乎会更自然一点。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; class Word &amp;lt; String             # Word inherits from String.
&amp;gt;&amp;gt;   # Returns true if the string is its own reverse.
&amp;gt;&amp;gt;   def palindrome?
&amp;gt;&amp;gt;     self == self.reverse        # self is the string itself.
&amp;gt;&amp;gt;   end
&amp;gt;&amp;gt; end
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里 Word &amp;lt; String 是Ruby的继承语法，这样就实现了在为字符串类加入新的方法的时候同样保持着原本的方法。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; s = Word.new(&amp;quot;level&amp;quot;)    # Make a new Word, initialized with &amp;quot;level&amp;quot;.
=&amp;gt; &amp;quot;level&amp;quot;                  
&amp;gt;&amp;gt; s.palindrome?            # Words have the palindrome? method.
=&amp;gt; true                     
&amp;gt;&amp;gt; s.length                 # Words also inherit all the normal string methods.
=&amp;gt; 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为 Word 类继承自String，我们可以使用console来看看它的继承情况：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; s.class
=&amp;gt; Word
&amp;gt;&amp;gt; s.class.superclass
=&amp;gt; String
&amp;gt;&amp;gt; s.class.superclass.superclass
=&amp;gt; Object
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个继承数可以用下图表示出来：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/word_inheritance_ruby_1_9.png&quot; alt=&quot;figure4.2&quot;&gt;&lt;/p&gt;

&lt;p&gt;Figure 4.2: The inheritance hierarchy for the (non-built-in) Word class from Listing 4.8.&lt;/p&gt;

&lt;p&gt;在例4.8 中，在Word类中我们调用了self和reverse函数来检查单词是否是对象本身的倒置。Ruby 中，使用 self 代表着实例本身：在Word类中，self就是字符串对象本身，这也意味着我们可以在例子中这样： &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;self == self.reverse
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来实现回文检查&lt;/p&gt;

&lt;p&gt;4.4.3 修改内置(build-in)类&lt;/p&gt;

&lt;p&gt;继承是一个非常强大的功能，在这个例子里，我们发现函数  palindromes 甚至比 palindrome? 更自然，因为我们可以直接用字符串对象调用它，但是这样的语句我们现在还没办法运行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; &amp;quot;level&amp;quot;.palindrome?
NoMethodError: undefined method `palindrome?&amp;#39; for &amp;quot;level&amp;quot;:String
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;酷的是，Ruby允许你通过打开类的方式来对内置类修改方法和定义自己的函数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; class String
&amp;gt;&amp;gt;   # Returns true if the string is its own reverse.
&amp;gt;&amp;gt;   def palindrome?
&amp;gt;&amp;gt;     self == self.reverse
&amp;gt;&amp;gt;   end
&amp;gt;&amp;gt; end
=&amp;gt; nil
&amp;gt;&amp;gt; &amp;quot;deified&amp;quot;.palindrome?
=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改一个内建的类是一个非常强大的技巧，但是能力越大责任越大，如果没有一个很好的理由去这么做，打开和修改内置类并不是一个好实践。Rails 有着一些很好的例子来告诉你为什么：例如，在一个 web 应用之中，我们常常想要防止变量是blank，例如，用户名不应该是空格(space)或者空白(whitespace)--因此，Rails为Ruby加入了一个 blank? 方法。我们在Rails console 中可以看到：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; &amp;quot;&amp;quot;.blank?
=&amp;gt; true
&amp;gt;&amp;gt; &amp;quot;      &amp;quot;.empty?
=&amp;gt; false
&amp;gt;&amp;gt; &amp;quot;      &amp;quot;.blank?
=&amp;gt; true
&amp;gt;&amp;gt; nil.blank?
=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看到一个空格的字符串并不为empty，但是他是 blank的，另外nil也是blanck的（因为nil不是一个字符串），这就说明Rails中blank?方法是插入字符串类的更高级类中的，事实上，它插入了 Object 类。&lt;/p&gt;

&lt;p&gt;4.4.4 控制器类&lt;/p&gt;

&lt;p&gt;说了那么多，我们现在应该对继承有了一些了解，我们再来看一下我们曾经看过的一些东西：在 StaticPagesController 中&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;class StaticPagesController &amp;lt; ApplicationController

  def home
  end

  def help
  end

  def about
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你现在应该很明白了，至少也应该模糊地明白了这个代码的含义： StaticPagesController 是一个继承自 ApplicationController 的类, 并且类中含有 home,help,about函数，因为每个Rails console 会根据本地 Rails 环境中加载，所以我们可以直接在命令行中测试我们的类继承关系：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; controller = StaticPagesController.new
=&amp;gt; #&amp;lt;StaticPagesController:0x22855d0&amp;gt;
&amp;gt;&amp;gt; controller.class
=&amp;gt; StaticPagesController
&amp;gt;&amp;gt; controller.class.superclass
=&amp;gt; ApplicationController
&amp;gt;&amp;gt; controller.class.superclass.superclass
=&amp;gt; ActionController::Base
&amp;gt;&amp;gt; controller.class.superclass.superclass.superclass
=&amp;gt; ActionController::Metal
&amp;gt;&amp;gt; controller.class.superclass.superclass.superclass.superclass
=&amp;gt; AbstractController::Base
&amp;gt;&amp;gt; controller.class.superclass.superclass.superclass.superclass.superclass
=&amp;gt; Object
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;据此画出的图表&lt;/p&gt;

&lt;p&gt;Figure 4.3: The inheritance hierarchy for the StaticPages controller.
&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/static_pages_controller_inheritance.png&quot; alt=&quot;figure4.3&quot;&gt;&lt;/p&gt;

&lt;p&gt;我们甚至可以在console中直接调用控制器中的函数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; controller.home
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;他将返回nil, 因为事实上它就是一个空的函数。&lt;/p&gt;

&lt;p&gt;不对啊？虽然action并没有返回任何值,好像也没有产生任何东西。但是我们在第三章看到，当我们访问 home 页面的时候，它确确实实返回了一个web页面，而不是一个值。而且我们似乎也从来没有在调用过 StaticPagesController.new ，不是么？这其中究竟发生了什么？&lt;/p&gt;

&lt;p&gt;发生的事情，都在Rails之中。Rails用Ruby写成，但是终究不是Ruby，有的Rails的类表现得和Ruby类一样，但是有的生来就是为了加工成网页大餐的。Rails中有很多这样的魔法，所以不要认为只要懂了Ruby你就能懂Rails。这就是为什么我建议先学Rails，然后你会需要学Ruby，你看，现在又回到学Rails的时候了！&lt;/p&gt;

&lt;p&gt;4.4.5 一个用户类&lt;/p&gt;

&lt;p&gt;在这一章的最后，我们为自己写一个类，这个用户类将被第六章的用户model替代。&lt;/p&gt;

&lt;p&gt;至今我们一直呆在Rails console的温室之中，现在，我们在application文件夹下面新建一个文件 example_user.rb 并输入： &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;Listing 4.9. Code for an example user. 
example_user.rb
class User
  attr_accessor :name, :email

  def initialize(attributes = {})
    @name  = attributes[:name]
    @email = attributes[:email]
  end

  def formatted_email
    &amp;quot;#{@name} &amp;lt;#{@email}&amp;gt;&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一下子看起来似乎挺多的，我们一步一步来，第一行：&lt;/p&gt;

&lt;p&gt;attr_accessor :name, :email&lt;/p&gt;

&lt;p&gt;建立了用户的可存取属性name 和 email 。它将为类实例建立 &amp;quot;getter&amp;quot; 和 &amp;quot;setter&amp;quot; 方法以便我们存取实例变量 @name 和 @email 。 在 Rails 中实例变量是可以通过类直接传递给视图文件并表示出来，而实例变量总是用@符号开头，而他们的初始化的值为 nil 。&lt;/p&gt;

&lt;p&gt;要第一个实现的方法： initialize, 对于 Ruby 来说是一个很特殊的方法：该方法会在执行 User.new 的时候被调用。这里initialize函数接受一个参数“attributes”:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;def initialize(attributes = {})
  @name  = attributes[:name]
  @email = attributes[:email]
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里attributes变量值就是空的哈希，所以我们可以定义一个没有email也没有name属性的用户。&lt;/p&gt;

&lt;p&gt;最后，我们的类定义一个方法 formatted_email ，我们用它来生成一串更友好的用户字符串：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;def formatted_email
  &amp;quot;#{@name} &amp;lt;#{@email}&amp;gt;&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为 @name 和 @email 都是实例变量，他们将在 formatted_email 方法中默认可用&lt;/p&gt;

&lt;p&gt;让我们打开console，我们的 user 文件引用上，看看效果如何：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;gt;&amp;gt; require &amp;#39;./example_user&amp;#39;     # This is how you load the example_user code.
=&amp;gt; [&amp;quot;User&amp;quot;]
&amp;gt;&amp;gt; example = User.new
=&amp;gt; #&amp;lt;User:0x224ceec @email=nil, @name=nil&amp;gt;
&amp;gt;&amp;gt; example.name                 # nil since attributes[:name] is nil
=&amp;gt; nil
&amp;gt;&amp;gt; example.name = &amp;quot;Example User&amp;quot;           # Assign a non-nil name
=&amp;gt; &amp;quot;Example User&amp;quot;
&amp;gt;&amp;gt; example.email = &amp;quot;user@example.com&amp;quot;      # and a non-nil email address
=&amp;gt; &amp;quot;user@example.com&amp;quot;
&amp;gt;&amp;gt; example.formatted_email
=&amp;gt; &amp;quot;Example User &amp;lt;user@example.com&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里， &amp;#39;.&amp;#39; 是 Unix 下“当前目录”的意思,而&amp;#39;./example_user&amp;#39;就是让Ruby在当前的目录之下找到与example user 相关的文件。&lt;/p&gt;

&lt;p&gt;记起来我们在Hash中学到的了么，我们可以用预先定义好的哈希参数来创建一个用户：&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;user = User.new(name: &amp;quot;Michael Hartl&amp;quot;, email: &amp;quot;mhartl@example.com&amp;quot;)
=&amp;gt; #&lt;User:0x225167c @email=&quot;mhartl@example.com&quot;, @name=&quot;Michael Hartl&quot;&gt;
user.formatted_email
=&amp;gt; &amp;quot;Michael Hartl &lt;a href=&quot;mailto:mhartl@example.com&quot;&gt;mhartl@example.com&lt;/a&gt;&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;在第七章我们还会遇上 叫 mass assignment 的技术，这在Rails中很常用。&lt;/p&gt;

&lt;p&gt;4.5 总结&lt;/p&gt;

&lt;p&gt;复习一下我们学到的Ruby知识。在第五章，我们要用他们开发构建自己的应用。
我们以后并不会实用 example_user.rb 文件，所以我建议你把它删了。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rm example_user.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，用git记录并管理你的代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git add .
$ git commit -m &amp;quot;Add a full_title helper&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
                <link>http://tutorial.railschina.org/rails%20%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B/2013/08/28/chapter-4</link>
                <guid>http://tutorial.railschina.org/rails%20%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B/2013/08/28/chapter-4</guid>
                <pubDate>2013-08-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>第三章 一个静态页面</title>
                <description>&lt;p&gt;翻译 &lt;a href=&quot;http://ruby.railstutorial.org/chapters/a-demo-app#top&quot;&gt;ruby on rails Tutorial&lt;/a&gt;,原作者 &lt;a href=&quot;http://michaelhartl.com/&quot;&gt;Michael Hartl&lt;/a&gt; .&lt;/p&gt;

&lt;h2&gt;第三章 Mostly static pages&lt;/h2&gt;

&lt;p&gt;在这一章中我们将开始开发一个例子程序，这个程序就是本书中接下来的所使用的例子。
尽管这个程序最终将会实现用户，微博信息，登录登出验证框架等，但是我们就从看起来蛮简单的开始——创建静态页面。尽管它很简单，但是创建静态页面是一项非常有意义和启发性的练习，对于我们新程序来说是一个完美的开端。
Rails虽然是用来设计数据库支持的动态网站，但是它也擅长用原生的HTML文件来产生静态网页。实际上用Rails产生静态网页会有明显的优势：我们可以非常容易的添加一小部分的动态内容。在这一章中我们也将学习如何添加这些内容。继续下去我们就将会第一次亲密接触自动测试，它会让我们对我们写过的代码更有自信。此外，有一个好的测试工具会是我们重构代码的时候更有信心——只改结构和形式没有改变它应有的功能。&lt;/p&gt;

&lt;p&gt;如第二章所说，我们从新建一个Rails的应用程序开始，这次叫它：sample_app&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;bash
$ cd ~/rails_projects
$ rails new sample_app -T
$ cd sample_app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里的 -T 参数是告诉 Rails 不要生成使用 Test::Unit 工具测试test文件夹。这意思是我门不要测试，正好相反，在第3.2节中我们将使用Rspec测试框架来代替 Test::Unit。&lt;/p&gt;

&lt;p&gt;回到我们的项目，我们接下来要做的是使用文本编辑器去修改Gemfile文件。我们需要添加一些我们程序需要的gem包，和前一章中所声明的，sqlite3-ruby的gem的版本是1.2.5，这和以前一样，是我们在本地开发所需要的gem（重申：我的系统需要1.2.5版本，如果你无法使用它，你可以使用1.3.1版本），另一方面，对于这个示例次序来说，我们还需要2个以前没用的gem：Rspec和 Rails的rspec库，
示例代码如代码3.1（提示：如果你想要提前把我们这个程序的所有gem都安装，我觉得你应该参考代码10.42）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;ruby 代码3.1：示例程序的Gemfile

source &amp;#39;http://rubygems.org&amp;#39;

gem &amp;#39;rails&amp;#39;, &amp;#39;3.0.3&amp;#39;
gem &amp;#39;sqlite3-ruby&amp;#39;, &amp;#39;1.3.2&amp;#39;, :require =&amp;gt; &amp;#39;sqlite3&amp;#39;

group :development do
  gem &amp;#39;rspec-rails&amp;#39;, &amp;#39;2.3.0&amp;#39;
end

group :test do
  gem &amp;#39;rspec&amp;#39;, &amp;#39;2.3.0&amp;#39;
  gem &amp;#39;webrat&amp;#39;, &amp;#39;0.7.1&amp;#39;
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码的开发模式里包含了rspec-rails，所以我们可以使用Rspec-specific生成器，在测试模式下包含了rspec，所以我们可以运行那些测试。（我们也包含Webrat测试工具，以前的版本它会被当成一个依赖包自动的添加，但是现在我们需要手动的添加它，它是目前用来生成页面测试的工具，所以我们需要它）。然后我们用Bundle install来安装这些gem。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了让Rails知道我们使用Rspec代替Test::Unit，我们需要安装一些Rspec需要的文件。我们可以通过 rails generate：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rails generate rspec:install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里，我要做的只剩下初始化Git库了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git init
$ git add .
$ git commit -m &amp;quot;Initial commit&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和第一程序一样，我还是建议更新“README”文件（位于程序的根目录。）。代码3.2的描述或许对你有些帮助。
&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;bash 代码 3.2 示例程序的README文件.

# Ruby on Rails Tutorial: sample application

This is the sample application for
[*Ruby on Rails Tutorial: Learn Rails by Example*](http://railstutorial.org/)
by [Michael Hartl](http://michaelhartl.com/).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，我们给他添上markdown的后缀名，然后提交它：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git mv README README.markdown
$ git commit -a -m &amp;quot;Improved the README&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/create_repository.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;图3.1： 创建示例程序的GitHub库&lt;/p&gt;

&lt;p&gt;为了将我们书中的程序放在github进行控制，增加一个新库是一个不错的主意。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git remote add origin git@github.com:&amp;lt;username&amp;gt;/sample_app.git
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(提示：到这一步 http://github.com/railstutorial/sample_app 库中的代码是示例程序所有的代码，欢迎咨询参考，但是有2点要注意：1，自己输入代码比使用现成的代码会学到更多的东西；2，书中提到Github库的代码有的会有差别，这主要是由于一方面这个库合并了本书中的练习和视频教程中的练习。)
当然，我也可以在现在就部署到Heroku，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ heroku create
$ git push heroku master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(如果错误可以参考代码1.8试着修复。) 在接下来的教程中，我建议你可以定期的push和发布程序；&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git push
$ git push heroku
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就可以开发示例程序了~&lt;/p&gt;

&lt;h3&gt;3.1 静态页面&lt;/h3&gt;

&lt;p&gt;Rails有2个主要的方法产生静态网页。第一，Rails可以处理由原生的HTML文件组成的真正静态页面（我也不明白什么意思，看下去吧）。第二，Rails允许我们定义rails可以渲染的含有原生HTML的视图，这样服务器可以将它发送到浏览器。
回忆一下第1.2.3（图1.2）节中所讲Rails的结构对我们把握中心是很有帮助的。这一节我们主要的工作目录是app/controllers 和 app/views，在3.2节中我们会接触到新的目录（我们甚至可以添加自己的目录.）；&lt;/p&gt;

&lt;h4&gt;3.1.1 真正的静态页面&lt;/h4&gt;

&lt;p&gt;让我们从真正的静态页面开始学习吧，回顾一下第1.2.5中关于每一个Rails程序一开始就就是一个非常小的程序（主要是Rails脚本的功劳，例如生成器）而且都有一个默认的欢迎页面（地址：http://localhost:3000/ .）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/public_index_rails_3.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;图片3.2 public/index.html文件&lt;/p&gt;

&lt;p&gt;看一下上图中代码，我们学习一下这个页面是从哪里来的。因为这个页面把样式直接包括进去，所以看起来有点乱，但是他的主要功能是：Rails将会把public文件夹下面的任何文件提供给浏览器。其中index.html文件是非常特别的，当你没有指定url地址的时候（http://localhost:3000/）他就是默认提供给浏览器的页面。当然你也可以包含它（http://localhost:3000/index.html）是没有区别的。
正如你所想的，如果我们喜欢，我们可以吧我们自己的静态网页像index.html文件一样放在public目录底下。所为例子，让我们创建一个问候用户的页面&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ mate public/hello.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;html 代码3.3问候的HTML页面

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Greeting&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;Hello, world!&amp;lt;/p&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在代码3.3中，我们看到一个典型的HTML文件：在头部声明document type（或者doctype），告诉浏览器HTML的版本（我们使用HTML5），在HTML的head中，我们设置“Greeting”作为title标签，在Body里面，我们在一个段落标签里放入了“Hello，world！”（上面的缩进可以不必理会，HTML的空格和tab键没影响。加上必要的排版可以让我们的文档更方便查看。）。好了，和上面说的一样，我们可访问地址:
http://localhost:3000/hello.html，Rails将会直接将页面返回给我们（图3.3）。
（HTML文本的title在浏览器的顶部。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/hello_world.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;图3.3我们自己的静态网页
上述页面只是为了示范而已。它可不是我们程序的一部分，所以我们应该删除掉它。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rm public/hello.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们先把index.html文件放一边，当然我们最终是要删除掉它的，我们可不想我们程序的根目录总是如图1.3所示那样的Rails默认页面。我们将会在第5.2节中学习如何让我们的地址“http://localhost:3000/”不指向public/index.html&lt;/p&gt;

&lt;p&gt;3.1.2 Rails静态页面&lt;/p&gt;

&lt;p&gt;可以返回静态页面是值得让人兴奋地，但是这对于开发一个动态web程序的来说并不是很有用。在这一节，我们学习创建动态页面的第一步：创建一些Rails的action方法，这些方法定义URL的能力比静态页面强很多。Rails的action方法在控制器里。第二章惊鸿一瞥的REST架构，我们将要在第六章深入的学习。本质上，controller是一组网页页面（可能是动态）的容器。&lt;/p&gt;

&lt;p&gt;我们从回忆第1.3.5节中，我们如何使用Git开始，将我们工作的内容单独放在一个分支里面比直接在master分支更值得我们借鉴。如果你使用Git版本控制，你可以运行一下代码&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git checkout -b static-pages
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Rails里面我们可以使用一个Generate的脚本来创建控制器；他的神奇之处就在于我们所要做的只是想一个控制器的名称。
由于我们的这个控制器主要用来处理静态页面，我们就叫他，Pages，而且我们希望给他几个action去响应Home page，contact page，和about page。我们可以在generate 脚本后面更上几个可选的参数作为actions，我们可以看到结果如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;ruby 代码3.4创建Pages控制器

$ rails generate controller Pages home contact
      create  app/controllers/pages_controller.rb
       route  get &amp;quot;pages/contact&amp;quot;
       route  get &amp;quot;pages/home&amp;quot;
      invoke  erb
      create    app/views/pages
      create    app/views/pages/home.html.erb
      create    app/views/pages/contact.html.erb
      invoke  rspec
      create    spec/controllers/pages_controller_spec.rb
      create    spec/views/pages
      create    spec/views/pages/home.html.erb_spec.rb
      create    spec/views/pages/contact.html.erb_spec.rb
      invoke  helper
      create    app/helpers/pages_helper.rb
      invoke    rspec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(注意，我们使用rails generate rspec：install来安装了Rspec所以，控制器自动在spec目录底下，生成了Rspec的测试文件。)。在这里，我故意遗忘了about page，我们可以在下一节3.2中学习如何手动添加它。
代码3.4中生成控制器的时候已经更新了routes的文件（位于config/routes.rb），Rails用该文件来查找URL和网页之间的对应关系。这是我们第一次遇到config这个文件夹，所以我们应该来快速的过一遍这个文件夹(如图3.4)。这个文件夹是rails放置一些配置文件的目录，故称其名。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/config_directory_rails_3.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;由于我们生成了home和contact的action方法，所以，routes文件已经为每一个action配置好了规则，如代码3.5：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;ruby config/routes.rb page控制器中home和contact的路由规则

SampleApp::Application.routes.draw do
  get &amp;quot;pages/home&amp;quot;
  get &amp;quot;pages/contact&amp;quot;
  .
  .
  .
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;规则：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;get &amp;quot;pages/home&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;映射了请求url：pages/home到Pages控制器的home方法。此外，使用get我们制定这个路由只会响应GET(一种HTTP协议（见Box3.1）支持的基础HTTP动作)的请求。对我们来说，我们在Pages的控制器中创建一个home的方法之后就自动的获得了一个页面地址“pages/home”，可以用Ctrl+C关闭服务器之后，重新启动（其实可以不用重启，rails的可以动态载入这些方法），然后访问pages/home（见图3.5）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/raw_home_view.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Box 3.1.GET和其他.&lt;/strong&gt;
HTTP协议定义了四种基本操作方式，分别是get，post, put, 和delete。这些是指在客户端和服务端之间的操作。（这个非常的重要，在开发中，一般客户端和服务器是同台机器，但是一般情况下，他们是不同的），强调HTTP动作是web框架（包括Rails）被REST架构影响的一个非常典型的特征。好处可以参考第2章，第八章会有深入的了解。&lt;/p&gt;

&lt;p&gt;get是HTTP操作中最常用的一个，一般用于请求数据。
它的意思就是“获取页面”，所以每次你访问google.com 或者craigslist.org 的时候，你的浏览器都是提交一个Get的请求。&lt;/p&gt;

&lt;p&gt;下一个常用的操作是Post，它一般在提交一个表单的时候使用。&lt;/p&gt;

&lt;p&gt;在rails里面Post的请求一般用于创建数据（尽管HTTP也允许post去实现更新。）&lt;/p&gt;

&lt;p&gt;比如，当你提交一个注册表单之后就会在服务器那边创建一个新的用户。&lt;/p&gt;

&lt;p&gt;另外2个操作时put和delete，前者用来更新远程服务器数据，后者用来删除数据。&lt;/p&gt;

&lt;p&gt;这2个没有前面2个操作那么普遍，有的浏览器没有支持发送这样的请求，但是一些web的框架（包括rails）有自己的方法去实现，让他发送这中请求。&lt;/p&gt;

&lt;p&gt;让我们从Pages的控制器开始看看，这些页面是哪里来的。如代码3.6所示（你可能注意到，这个和第二章中的Users和Microposts控制器有区别，这个控制器并没有遵循REST规则。）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;ruby 代码 3.6代码3.4产生的控制器代码。
class PagesController &amp;lt; ApplicationController

  def home
  end

  def contact
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看到pages_contoller.rb文件中定义了PagesController类。类是把功能（或方法，就像用def定义的home和contact方法一样。）组织起来的一种简单方法。尖括号“&amp;lt;”便是PacgesController从Rails的ApplicationContoller类；
正如我们将看到，这说明了我们的网页装备了大量的Rails的特定功能（我们将会在第4.4节中学习类个继承。）
在这里，控制器中页面的方法都是空的。
在ruby里，这些方法什么都不做，但是在Rails里面却有点却别。PagesController是一个Ruby的类，但是由于他继承自ApplicationController。所以他的方法有一些特别。当我们访问URL /pages/home、 Rails寻找Pages的控制器，然后执行home的方法，然后渲染页面响应页面的动作。因为在上面home的方法是空的，所以他除了渲染页面之外什么也没做。所以页面应该什么样子，我们应该如何找到它呢。
如果你再看看代码3.4的输出，你可能会猜出页面和方法之间的关系：一个方法如home页面对应一个视图如home.html.erb。我们将会在3.3中学“.erb”的意义。从&amp;quot;.html&amp;quot;部分你也不用惊讶它看起来是基于HTML。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;html app/views/pages/contact.html.erb
&amp;lt;h1&amp;gt;Pages#contact&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;Find me in app/views/pages/contact.html.erb&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;contact方法类似：
    html app/views/pages/contact.html.erb
    &lt;h1&gt;Pages#contact&lt;/h1&gt;
    &lt;p&gt;Find me in app/views/pages/contact.html.erb&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;以上2个页面就类似占位符：一个顶级的h1标签，和一个包含了相关文件绝对路径的的P标签。我们从第3.3节开始学习添加一些动态（少量）的内容，但是他们说明了一个重要的知识：Rails的页面可以使只含有静态HTML的。只要浏览器链接，就很难区别开到底是由3.1.1中的静态页面显示，还是由控制器方法提供页面：因为浏览器都只看到HTML。
在这一章剩下的内容，我们将学习在3.1.2中故意遗漏的“about”，添加非常少的动态内容，然后第一次涉及页面的CSS样式。在进入下面的学习之前，我们应该将变动添加到Git的库里面去。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git add .
$ git commit -am &amp;quot;Added a Pages controller&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你或许想起来，我们再1.3.5节里面使用  git commit -a -m &amp;quot;Message&amp;quot;命令，用-a表示“all change”，用-m表示“信息”；git也允许我们将2个参数合到一起“-am”、我在本书中将会继续使用这种简写。&lt;/p&gt;

&lt;h3&gt;3.2 我们的第一个测试&lt;/h3&gt;

&lt;p&gt;如果你去问五个 Rails 开发者如何去测试一段代码，你会得到15种不同的答案————不过他们都会认为写下测试代码是必要的。测试一段代码是一种精神，把一段心目中的想法写成测试而不用担心什么问题会让你的开发更佳完美。你也没有必要把 这里的测试方式当成是圣经，它们只不过是那些我从自己和我读到的代码中用到的东西。如果你想成为一个有经验的 Rails 开发者，你无疑在某日形成一个自己的测试开发风格的。&lt;/p&gt;

&lt;p&gt;另外，在我们的示例程序中我们编写测试程序用了一种最近很流行的方法 在开发前编写测试文件（when to write tests by writing them before the application code）————一种测试驱动开发的方法，也叫TDD。我们的应用将要增加一个 About 页面。不用担心，增加一个额外的页面并不难————你或许都已经通过上面的学习猜到答案了————但是这一次我们要著重于测试文件的编写。&lt;/p&gt;

&lt;p&gt;虽然为一个已经存在的界面进行测试似乎是有点闲的蛋疼，但是我的经验告诉我事实不是这样的。许多代码会写着写着就错了，有一个好的测试来约束你能够保证你的程序质量。另外，对于一个计算机程序来说，尤其是一个网络应用来说，扩展性是很重要的，这样每当你添加一个功能你都会面临一份程序写&amp;quot;跑题&amp;quot;了的危险。写下测试并不意味着程序中的bug会小时，而是让他们更容易被抓到和修复。而有的人确实会为抓bug而写测试。
  (正如我们在1.1.1中说的那样，如果你发现测试非常的让你头疼，你完全可以只把教程中的Ruby on Rails 抽出来先学习，然后再自行学习测试方面的技巧).&lt;/p&gt;

&lt;h4&gt;3.2.1 测试工具&lt;/h4&gt;

&lt;p&gt;为了给我们的示例程序进行测试，我们的主要工具是一个测试框架，叫做 &lt;a href=&quot;http://rspec.info/&quot;&gt;RSpec&lt;/a&gt;,它使用“特别管理语言”来描述代码的行为，并判断代码是否完成了对应的工作。在Rails社区中，RSpec 测试Ruby程序十分高效，以至于 Obie Fernandez ， The Rails 3 way 的作者把RSpec 叫做 “Rails必由之路”，我在这里也表示赞同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;autotest&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Autotest 是一个在你更改程序的时候，在后台自动帮你进行测试的套件。例如，如果你把一个 controller 改了 ，Autoest 就立马会对那个controller对应的view进行测试，测试结果也会马上反馈回来。我们会在 3.2.2 学到更多关于 Autotest 的东西。&lt;/p&gt;

&lt;p&gt;安装 Autotest是可选的，不过安装Autotest 有点犯人，不过我保证当你发现它是多么的有用的时候你会觉得一些都是值得的。首先你要先安装一下 autotest 和 autotest-rails-pure 这两个gems&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$gem install autotest -v 4.4.6
$gem install autotest-rails-pure -v 4.1.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(如果你在这里遇到了 “权限不够”的提示的话那你可能需要使用 sudo 命令来运行它们)。&lt;/p&gt;

&lt;p&gt;下一个步骤将要取决与你的系统平台，我会在这里用我的 OS X 来做演示，然后我会给出几篇关于安装在linux 和 windows方法 的 blog。在 OS X 上，你需要先安装 &lt;a href=&quot;http://growl.info/&quot;&gt;Growl&lt;/a&gt; 然后安装 auto-fsevent 和 autotest-growl 两个gems。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ gem install autotest-fsevent -v 0.2.4
$ gem install autotest-growl -v 0.2.16
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果fsevent安装除了问题的话 ，你最好检查一下 你机子上的 Xcode 是否正常工作。&lt;/p&gt;

&lt;p&gt;要想使用Growl 和 FSEvent 的Gem ，你需要把Autotest 的配置文件放到你的工作文件夹的根目录下面。并且在按如下方法添加一些文件内容：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ mate .autotest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置文件需要加入：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;require &amp;#39;autotest/growl&amp;#39;
require &amp;#39;autotest/fsevent&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者你可以加入：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;require &amp;#39;autotest-growl&amp;#39;
require &amp;#39;autotest-fsevent&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（这个设置文件只对你当前的应用程序起作用，如果你想要让你的所有 ruby 和rails 项目共享这一配置，你可以把这个  &lt;code&gt; .autotest &lt;/code&gt;放到你的个人文件根目录下面去）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ mate ~/.autotest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你实在Linux的Gnome的桌面系统之下的话。我建议你尝试一下 这里（[Automate Everything]）的东西[http://automate-everything.com/2009/08/gnome-and-autospec-notifications/].通过它可以让你在 linux 上面运行和 OS X 差不多的 Growl 提示。至于 Windows 用户 ，你们可以尝试安装
&lt;a href=&quot;http://www.growlforwindows.com/gfw/&quot;&gt;Growl for Windows&lt;/a&gt;,然后跟着 &lt;a href=&quot;http://github.com/svoop/autotest-growl&quot;&gt;GitHub 的 autotest-growl页面&lt;/a&gt;来做。不管是linux还是windows的用户都应该看看&lt;a href=&quot;http://github.com/carlosbrando/autotest-notification&quot;&gt;autotest-notification&lt;/a&gt;, Rails Tutorial 的读者 Fred Schoeneman 写了一篇&lt;a href=&quot;http://fredschoeneman.posterous.com/pimp-your-autotest-notification&quot;&gt;博文&lt;/a&gt;也很值得一看.&lt;/p&gt;

&lt;h4&gt;3.2.2 TDD:红灯，绿灯，重构&lt;/h4&gt;

&lt;p&gt;对于测试驱动开发来说，我们通常会事先写一个失败的测试————失败意味着是不能通过。在我们这个例子当中，刚开始我们就会写一段验证：“应该会是 about page ”的页面测试代码，当然这个时候about页面没有出现，所以如果运行测试的就会失败。如果要想让测试通过，我们就应该加入和about页面对应的行为和视图。那为什么我们反过来做，先写功能，在做测试呢？这是为了保证我们确确实实加入了我们所需要的特性。在我刚开始使用 TDD 的时候，我先为我自己的程序中又那么多的错误感到惊讶，然后慢慢让测试出的错误消失，确保刚开始测试的失败然后再慢慢让它成功，我们就会慢慢对我们写出的代码更有信心。&lt;/p&gt;

&lt;p&gt;还有一点非常重要，TDD并非任何时候都使用的，尤其是，当你对某个问题还没有个确切的解决方法的时候。这时候通常会先忽略测试而直接完成功能代码（在极限编程 XP 中，这种试探性的步骤叫做 spike ），而一旦你发现了一个确切的方法去解决这个问题之后，你就可以重新用TDD来更优雅实现一个新的版本。&lt;/p&gt;

&lt;p&gt;“红，绿，重构 ”是在测试驱动开发中使用的方法，第一步：红，指的是写一个失败的测试，大部分测试工具会在这里以红色指出错误，第二步：绿，意味着测试通过，然后当我们的测试都成功通过之后我们就可以在不改变功能的条件下随意的重构我们的代码：删除重复，更改设计模式等等。&lt;/p&gt;

&lt;p&gt;当然现在我们还什么颜色都没有，让我们先从红色开始把，RSpec（其他的测试工具也一样）在刚开始可能又一些吓人，我们这里先从 rails generate controller pages （Listing3.4） 开始。这里因为我不太喜欢把 views/helpers 分离出来测试（我觉得这样很多余），我们的第一步就是把他们移除掉。如果你在使用 Git ，你可以这么做：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$git rm -r spec/views
$git rm -r spec/helpers
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们再把文件也移除了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rm -rf spec/views
$ rm -rf spec/helpers
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在开始前，我们来看看我们刚刚建立的 Page 的Controller 的 spec&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;ruby spec/controllers/pages_controller_spec.rb
require &amp;#39;spec_helper&amp;#39;

describe PagesController do

  describe &amp;quot;GET &amp;#39;home&amp;#39;&amp;quot; do
    it &amp;quot;should be successful&amp;quot; do
      get &amp;#39;home&amp;#39;
      response.should be_success
    end
  end

  describe &amp;quot;GET &amp;#39;contact&amp;#39;&amp;quot; do
    it &amp;quot;should be successful&amp;quot; do
      get &amp;#39;contact&amp;#39;
      response.should be_success
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是纯粹的Ruby代码，但是即使你学习过Ruby你恐怕也不能看明白这些东西是什么意思。这是因为RSpec为了测试专门为Ruby语言进行了扩展，用的是一种 “domain-specific-language”（DSL）语言，这种语言的特点就是你完全不知道它的语法也可以使用RSpec,刚开始这或许看起来会有点不可思议，但是没有关系，Rspec 测试脚本读起来基本就和英语一样，如果你已经做了前面的那些 generate 和 实例程序之后我想搞定它也不难。&lt;/p&gt;

&lt;p&gt;上面的代码中包括了两个 &lt;code&gt; describe &lt;/code&gt; 代码块，他们与我们的 example 一一对应，这里我们先来看看第一个 describe 是怎么回事。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;ruby
  describe &amp;quot;GET &amp;#39;home&amp;#39;&amp;quot; do
    it &amp;quot;should be successful&amp;quot; do
      get &amp;#39;home&amp;#39;
      response.should be_success
    end
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，第一行指出我们正在对于 HOME 页面进行一个 GET 操作，这仅仅是一个描述性的语句，你完全可以在这里写任何你想要的东西，RSpec不会在乎的（其他人类会在乎的）。在这里 GET ‘home’ 指的是测试 HOME 相对应的 HTTP GET 请求，如同 上面 BOX 3.1 中讨论的那样。然后 RSpec 说如果你你访问了 HOME 页面，应该能够成功返回。这里的第一行其实和测试行为完全不相干的，仅仅是是对人类读者的一种描述行记录。第三行 &lt;code&gt;get ‘home’&lt;/code&gt; 在这里RSpec才真正开始干活了，这里RSpec会先提交一个 GET 请求，换一句话说，在此时RSpec相当于打开浏览器并且链到你的网页上，这个网页就是你的 ** /PAGES/HOME ** (RSpec之所以知道控制器是 PAGES 因为我们在做的是 PAGES CONTROLLERS 的测试，访问HOME 则是因为你明确告诉了它)。最后，第四行告诉它这个页面应该会成功的返回（也就是说他应该返回一个状态码 200 ）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Box 3.2 HTTP 返回码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在一个客户端（例如浏览器）发送了一个HTTP的动词请求的时候，网络服务器会在返回的时候加上一段数字代码来作为 HTTP 状态字。例如状态字 200 意味着 “成功”，状态字301 意味着 “静态跳转” ，如果你安装了 curl ，一个可以解析HTTP请求的命令行客户端，你就可以直接看到状态字。例如访问 &lt;code&gt; www.google.com &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;$ curl --head www.google.com
 HTTP/1.1 200 OK
 .
 .
 .&lt;/p&gt;

&lt;p&gt;在这里谷歌就成功完成了你的请求并且返回了状态码 200 OK .同样， GOOGLE.com  会静态的跳转到 www.google.com 所以他会指向一条 301 的状态码 （301 跳转）&lt;/p&gt;

&lt;p&gt;$ curl --head google.com
  HTTP/1.1 301 Moved Permanently
  Location: http://www.google.com/
  .
  .
  .
(注意，这个范例将会随着你的国家不同而又很大差别。。。)&lt;/p&gt;

&lt;p&gt;当我们在RSpec 的测试文件里面写了 response.should be_success ，RSpec会识别出我们的应用返回了一个正确的 200代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在是时候让我们的测试跑起来了。这里有几种不同的方法来运行测试（但是总体上大同小异）。第一种方法是在命令行里运行 rspec 脚本，像这样&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle exec rspec spec/
....

Finished in 0.07252 seconds

2 examples, 0 failures
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（不幸的事，很多事情可能让你在这个时候运行出 fail ，如果你中枪了，你可以尝试着用命令 “bundle exec rake db:migrate” 来 migrate 一下数据库。如果rspec还是不工作，那你恐怕就要重新卸载安装数据库了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ gem uninstall rspec rspec-rails
$ bundle install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这也不行你那你恐怕就要用 RVM 来重新卸载安装你的 gems 了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rvm gemset delete rails3tutorial
$ rvm --create use 1.9.2@rails3tutorial
$ rvm --default 1.9.2@rails3tutorial
$ gem install rails -v 3.0.11
$ bundle install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这也不行，那我也没办法了 -_- .)&lt;/p&gt;

&lt;p&gt;当你运行了 &lt;code&gt;bundle exec rspec spec/&lt;/code&gt; 的时候, rspec 是作为一个由Rspec提供的程序来运行的，而 spec/ 是一个你所需要测试的目录。你也可以 rspec 只运行测试一个目录下的文件例如这个例子就运行spec测试了 controller ：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle exec rspec spec/controllers/
....
Finished in 0.07502 seconds

2 examples, 0 failures
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你甚至可以运行一个单独的文件&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle exec rspec spec/controllers/pages_controller_spec.rb
....
Finished in 0.07253 seconds

2 examples, 0 failures
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，在这里我们再一次运用了 bundle exec 来执行我们的命令（bundle exec 可以以Gemfile中指定的gems版本来执行命令），因为这样命令看起来有一点冗长，所以 Bundler 允许创建二进制的程序集例如这样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle install --binstubs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样一来所有需要的gems执行程序都将会生成到 bin/ 文件夹下面去。我们现在就可以直接这样运行：$&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;bin/rspec spec/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;rake也一样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bin/rake db:migrate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于不想这么做的朋友们，那么在将来的课程里你们恐怕需要都用 bundle exec 来运行这些特定的命令了（当然也可以选择这个简单些的办法.）&lt;/p&gt;

&lt;p&gt;由于这个页面控制器目前是我们唯一的测试文件，所以这三个命令应该输出都是一样的。在剩下的教程里面，我们不会把运行test的命令行打出来，但是你自己要知道用bundle exec rspec spec/ （或者其他的东西），或者自己用autotest之类的东西。&lt;/p&gt;

&lt;p&gt;如果你安装了 Autotest 你可以自动进行的RSpec测试：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ autotest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你用的是 Mac 的 Growl 测试工具，你可以向我一样，如下图一样，autotest在后台运行，Growl 会提醒你当前测试的状态，这样用 TDD 是会上瘾的。 &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/autotest_green.png&quot; alt=&quot;autotest&quot;&gt;&lt;/p&gt;

&lt;h4&gt;Spork&lt;/h4&gt;

&lt;p&gt;在前面的例子里你可能已经注意到了，用这样的套件运行一次测试非常的慢（the overhead involved in running a test suite can be considerable.不知道是不是这意思）。这是因为每次运行RSpec来进行一次测试都会 Reload 一次 Rails 环境。Spork test server 就是针对这个问题产生的。&lt;/p&gt;
</description>
                <link>http://tutorial.railschina.org/rails%20%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B/2013/08/28/chapter-3</link>
                <guid>http://tutorial.railschina.org/rails%20%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B/2013/08/28/chapter-3</guid>
                <pubDate>2013-08-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>第二章 测试应用</title>
                <description>&lt;h3&gt;第二章&lt;/h3&gt;

&lt;p&gt;翻译 &lt;a href=&quot;http://ruby.railstutorial.org/chapters/a-demo-app#top&quot;&gt;ruby on rails Tutorial&lt;/a&gt;,原作者 &lt;a href=&quot;http://michaelhartl.com/&quot;&gt;Michael Hartl&lt;/a&gt; .&lt;/p&gt;

&lt;h2&gt;示例程序&lt;/h2&gt;

&lt;p&gt;在这一章里面，我们将会开发一个演示性的程序来展示 Rails 的强大。目的是为了能够从比较高的层面上理解如何通过 Ruby on Rails 的 scaffold generators 功能进行 rails 敏捷开发。在上一章的推荐书目中，有的书运用了相反的方法，通过一点点的增加新功能开发一个完整的应用程序，同时解释相关的概念。但是在我们的这个实例程序中，脚手架（scaffold）功能是无可替代的，它将迅速而全面的通过 URLs 来让我们了解rails的组成结构和 REST 特性。&lt;/p&gt;

&lt;p&gt;这个示例程序完成了用户和与用户关联的微博（像是超级简化的twitter）。由于这个程序用到的功能隐藏了许多细节，所以这里很多步骤可能会看起来像是魔法，但是别担心，我们会从第三章开始从底层开发一个类似的应用，保证会让你能学到rails最重要的特性的。所以现在，就请乖乖的从这里开始学习Rails，制作我们这章的， 超酷脚手架驱动（superficial, scaffold-driven ）应用吧。&lt;/p&gt;

&lt;h3&gt;2.1 计划整个应用程序&lt;/h3&gt;

&lt;p&gt;在这里我们先跳出我们的示例程序，和1.2.3节中一样，我们要用rails命令来建立一个rails的基本框架：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ cd ~/rails_projects
$ rails new demo_app
$ cd demo_app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后如同 2.1节，我们用文本编辑器来更改Gemfile：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;source &amp;#39;http://rubygems.org&amp;#39;

gem &amp;#39;rails&amp;#39;, &amp;#39;3.0.11&amp;#39;
gem &amp;#39;sqlite3&amp;#39;, &amp;#39;1.3.3&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们接着安装被包括到Gemfile中的 bundle&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后我们新建一个Git仓库并做一次确认&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git init
$ git add .
$ git commit -m &amp;quot;Initial commit&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/create_demo_repo.png&quot; alt=&quot;Creating a demo app repository at GitHub. &quot;&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git remote add origin git@github.com:&amp;lt;username&amp;gt;/demo_app.git
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们就已经做好了准备工作了，对于建立一个网络应用程序通常我们会先建立一个数据库模型来展现出这个应用的数据结构。对于我们来说，这个实例程序只有简单的一层关系：每个用户拥有许多微博。所以我们会先建立用户模型，然后为用户模型添加微博。
&amp;lt;!--more--&amp;gt;&lt;/p&gt;

&lt;h4&gt;2.1.1 用户模型&lt;/h4&gt;

&lt;p&gt;user不用的结构对应着在页面上会有不同的表格，我们用最简单的结构来创建User model，它有一个唯一的int类型的主键，id，和一个公共可见的名字，string类型，和一个email地址，可以看做用户的第二用户名。所以，user的数据模型如下图2.2所示，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dl.iteye.com/upload/attachment/367717/04b466eb-0d36-36ba-84b5-96c28ee04ac8.png&quot; alt=&quot;user model&quot;&gt;&lt;/p&gt;

&lt;p&gt;图2.2&lt;/p&gt;

&lt;p&gt;我们将在6.1.1节中学到，上表中的Users标签，代表着在数据库中的一个users表，上表的属性就是它的字段。&lt;/p&gt;

&lt;h4&gt;2.1.2 微博模型&lt;/h4&gt;

&lt;p&gt;micropost的数据模型比user的更简单，它只有一个id和一个string类型的content来代表发言的内容。有一个附加的关系，我们希望将micropost和特定的user联系起来，我们可以可以添加一个user_id来记录post的所有者，这样，micropost的最终结果如图2.3所示，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dl.iteye.com/upload/attachment/367723/52b778a4-8e43-3074-b2c5-3d0738495adc.png&quot; alt=&quot;microposts model&quot;&gt;&lt;/p&gt;

&lt;p&gt;\                                           图2.3&lt;/p&gt;

&lt;p&gt;我们可以在2.3.3节（更详细的在第11章）中找到user_id的属性如何可以让我们更简单的表达user和micropost之间一对多的关系。&lt;/p&gt;

&lt;h3&gt;2.2用户资源&lt;/h3&gt;

&lt;p&gt;在这一节，我们将实现2.1.1节中User数据模型的网络接口。通过这个网络接口和模型的组合，使我们可以通过HTTP协议来实现对user资源的CRUD（添加，查询，更新，和删除）
简介里面提到的，我们的User资源将会通过脚手架生成器（Scaffold generator）来产生。脚手架生成器是每一个Rails项目的标配；scaffold的参数是要产生的资源名称，在这里是User，后面可以的可选参数，可以使数据模型的属性和类型。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rails generate scaffold User name:string email:string
          invoke  active_record
          create    db/migrate/20100615004000_create_users.rb
          create    app/models/user.rb
          invoke    test_unit
          create      &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;/unit/user_test.rb
          create      &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;/fixtures/users.yml
           route  resources :users
          invoke  scaffold_controller
          create    app/controllers/users_controller.rb
          invoke    erb
          create      app/views/users
          create      app/views/users/index.html.erb
          create      app/views/users/edit.html.erb
          create      app/views/users/show.html.erb
          create      app/views/users/new.html.erb
          create      app/views/users/_form.html.erb
          invoke    test_unit
          create      &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;/functional/users_controller_test.rb
          invoke    helper
          create      app/helpers/users_helper.rb
          invoke      test_unit
          create        &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;/unit/helpers/users_helper_test.rb
          invoke  stylesheets
          create    public/stylesheets/scaffold.css
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令后面跟上 name：string 和email：string，可以让我们在rails自己产生的页面表单中有这2个数据模型的属性。如图2.2，提示，在命令中没必要添加属性id，因为他会被rails自动创建。
程序的第一步，我们应该使用rake运行数据库迁移，如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rake db:migrate
    &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;  CreateUsers: &lt;span class=&quot;nv&quot;&gt;migrating&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;====================================================&lt;/span&gt;
    -- create_table&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;:users&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
       -&amp;gt; 0.0017s
    &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;  CreateUsers: migrated &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.0018s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===========================================&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就这样非常简单的更新了数据库，我们创建了一个新的users数据模型，我们将会在6.1.1节中学习数据库迁移migrations。
（如果大家的数据库是空的，或者程序新建的话，先运行 rake db：create，他会创建开发环境和测试环境的数据库）
之后我们可以通过命令 rails s（rails server的简写）来启动服务器，
（该命令也可以带参数，可以设置启动的服务器，默认启动的是WEBrick，也可以设置启动的环境，默认是开发环境）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rails &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;gt; Booting &lt;span class=&quot;nv&quot;&gt;WEBrick&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;gt; Rails 3.0.3 application starting on http://0.0.0.0:3000
    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;gt; Call with -d to &lt;span class=&quot;nv&quot;&gt;detach&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;gt; Ctrl-C to shutdown server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以在 http://localhost:3000/上看到我们的演示程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Box 2.1&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Rake&lt;/strong&gt;         :
在Unix系统上，make工具在执行源代码上有着非常重要的作用，非常多的电脑黑客输下面的代码输到不用大脑了。。。（可以这样翻译吧。。。muscle memory）
  $ ./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; sudo make install
通常这个使用与在unix（包括linux和Mac OS X）底下编译源码；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;rake可以说是ruby的make工具,他是用ruby写的类似make的语言或者说是工具；rake在rails里的运用非常广泛，特别是在开发有数据库支持的web程序中用于大量小任务的管理；
rake db:migrate命令可能是最经常使用到的，但是这只是其中之一，你可以运行
    $ rake —T db
的命令来查看rake命令中关于数据库的小任务；
    $ rake —T
可以查看所有可用的任务；
出现的列表可能让人觉得恶心，但是不要担心，现在你不必要知道列表中所有项（或者大部分）的意思，学完本书后，你会知道里面所有重要的任务项.&lt;/p&gt;

&lt;h4&gt;2.2.1 用户模块开发&lt;/h4&gt;

&lt;p&gt;打开项目的根目录，http://localhost:3000/ 将会如图1.3（第一章的图。我挪过来了）所示的显示rails默认的根目录，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dl.iteye.com/upload/attachment/367806/d7bba2bc-be01-3135-a5c6-441712dc19fb.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;\                                   图1.3&lt;/p&gt;

&lt;p&gt;在生成User的资源的时候，我们也创建了很多的页面，用于操作这个用户；
例如，用于列出所有用户的 “/users”页面，用于创建新用户的“/users/new”页面等，
本节剩下的部分会用来快速的访问并解说这些页面，随着我们的进行，我们可以把页面和URL的关系列在下表中，&lt;/p&gt;

&lt;p&gt;&lt;br&gt;
&lt;table class=&quot;bbcode&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;URL&lt;/td&gt;&lt;td&gt;   Action&lt;/td&gt;&lt;td&gt; Purpose&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;/users &lt;/td&gt;&lt;td&gt;index  &lt;/td&gt;&lt;td&gt;page to list all users&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;/users/1&lt;/td&gt;&lt;td&gt;  show    &lt;/td&gt;&lt;td&gt;page to show user with id&lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;/users/new&lt;/td&gt;&lt;td&gt;   new&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/td&gt;&lt;td&gt;page to make a new user&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;/users/1/edit&lt;/td&gt;&lt;td&gt;    edit&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/td&gt;&lt;td&gt;page to edit user with id &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;Table 2.1: 用户资源和URL之间的关系对照&lt;/p&gt;

&lt;p&gt;我们从列出所有用户的index 页面开始吧，和你想的一样，一开始是什么都没有，如图2.4所示，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dl.iteye.com/upload/attachment/368100/9187441f-a73a-367b-b2e6-e1ba2b5cd785.png&quot; alt=&quot;pict&quot;&gt;&lt;/p&gt;

&lt;p&gt;\                               图2.4    初始状态下的index页面(/users).&lt;/p&gt;

&lt;p&gt;我们通过&amp;quot;users/new&amp;quot;页面来创建新的用户，如图2.5所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dl.iteye.com/upload/attachment/368103/e2c436e2-53d1-3518-a4e2-53c6a9c13506.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;\                               图 2.5: 创建用户页面 (/users/new).&lt;/p&gt;

&lt;p&gt;我们可以在页面中输入用户name和email的值，然后点击Create按钮。
成功之后呢会跳向show页面，如图2.6所示，（绿色的欢迎信息是成功创建后flash的信息，我们将在8.3.3中学习它）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dl.iteye.com/upload/attachment/368106/eb735daa-d41b-3ca0-ae7f-78a6efd77ad4.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;\                               图2.6，显示一个用户信息的页面(/users/1)&lt;/p&gt;

&lt;p&gt;注意此时的URL是 “/users/1”，你可能想到，那个1个就是代表图2.2中用户的id属性。
在7.3节中，这个页面就会变成用户的详细信息页。
我们通过访问edit页面来修改用户信息，如图2.7所示，我们修改信息后点击更新按钮。在演示程序中，我们可以修改用户信息，我们将在第六章中详细的介绍，这些用户的信息是被存储在数据库中的。我们将会把添加编辑用户的功能加入第10.1节的示范程序中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dl.iteye.com/upload/attachment/368170/2cce9343-7ec9-367f-8963-2a103139a9ff.png&quot; alt=&quot;picc&quot;&gt;&lt;/p&gt;

&lt;p&gt;\                                 图2.7 用户编辑页面(/users/1/edit).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dl.iteye.com/upload/attachment/368179/89b60b5b-537a-3ef9-a146-bb217c4916e8.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;\                                图2.8 用户更新成功页面.&lt;/p&gt;

&lt;p&gt;现在我们可以通过new页面填入和提交信息再创建一个用户；所以，在index页面中就会如下图2.9所示。在第10.3节中巍峨哦门将开发一个更精致index页面来列出所有用户。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dl.iteye.com/upload/attachment/368179/89b60b5b-537a-3ef9-a146-bb217c4916e8.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;\                           图2.9 加入了第二个用户的index页面(/users).&lt;/p&gt;

&lt;p&gt;在演示了如何创建，显示，修改单个用户之后，我们将要看看如何删掉他们。你必须验证下图中用于删除第二个用户的链接是正确的。如果它不能使用，首先应该保证你的浏览有把javascript打开，Rails用JavaScript来发送删除用户的请求的。
我们将会把添加删除用户的功能加入到第10.4节的示例程序。在一个管理用户的类中小心的使用它。
&lt;img src=&quot;http://dl.iteye.com/upload/attachment/368196/01cf1ae1-3a89-38e5-800b-a36db253baf0.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;\                           图2.30 删除一个用户&lt;/p&gt;

&lt;h4&gt;2.2.2 上节操作的MVC应用&lt;/h4&gt;

&lt;p&gt;现在我们基本完成了用户资源，让我们用一个过程来讲述第1.2.6中提到的MVC模式，这个模式可以只是浏览器上普通的一次点击。例如访问user的index页面“/users”;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dl.iteye.com/upload/attachment/368202/23d6b46a-2b50-3cda-8352-732936b18ccc.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;\                      图2.11，Rails中MVC的详细图解&lt;/p&gt;

&lt;p&gt;\                       上表中步骤对应：&lt;/p&gt;

&lt;p&gt;1.The browser issues a request for the /users URL.    浏览器发送请求/users
2.Rails routes /users to the index action in the Users controller.    Rails的路由组建分析它为对应users 控制器，index 的方法。
3.The index action asks the User model to retrieve all users (User.all).    index通过User.all方法请求用户模型查找所有的用户。
4.The User model pulls all the users from the database.    User模型从数据库提取出所有需要的用户。
5.The User model returns the list of users to the controller.    User模型返回用户列表给控制器。
6.The controller captures the users in the @users variable, which is passed to the index view.    控制器将这些用户注入@users的类变量中。该变量将会被传到视图中使用。
7.The view uses Embedded Ruby to render the page as HTML.    视图利用内嵌的ruby代码来产生HTML文件；
8.The controller passes the HTML back to the browser.7    控制器将HTML传回浏览器&lt;/p&gt;

&lt;p&gt;我从浏览器（如IE）的地址栏出入URL或者点击一个链接开始发出一个请求，这个请求将会先会请求rails的“路由器router”，路由器将会基于URL选择目标控制器和ACTION（在BOX3.1中我将看到请求的方法。）。下表中的代码会为用户资源创建一个URL到控制器action的映射，这些代码会创建如前面表2.1所示的那样URL/action 对应关系。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Listing 2.2. Rails的映射Users 资源的路由.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;``` ruby  config/routes.rb&lt;/p&gt;

&lt;p&gt;DemoApp::Application.routes.draw do
      resources :users
      .
      .
      .
    end&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;在第2.2.1中的页面对应了User控制器中的各个action。控制器是由Rails的scaffold生成器生产的，结构如listing 2.3所示。

提示， class UsersController \&amp;lt; ApplicationController 的写法是Ruby中类继承的写法。（我们将会在第2.3.4中简短的介绍继承，在第4.4中详细介绍。）

####Listing 2.3. Users控制器示意图。



``` ruby app/controllers/users_controller.rb
    class UsersController &amp;lt; ApplicationController

      def index
        .
        .
        .
      end

      def show
        .
        .
        .
      end

      def new
        .
        .
        .
      end

      def create
        .
        .
        .
      end

      def edit
        .
        .
        .
      end

      def update
        .
        .
        .
      end

      def destroy
        .
        .
        .
      end
    end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.3Microposts资源&lt;/h3&gt;

&lt;p&gt;在生成和探索了Users资源之后，让我们转过来看看另一个相关资源——Microposts。
在这一节中，我建议对比一下2个资源中相似的元素。你会看到2个资源之间会有很多地方都是相同的。Rails程序的RESTful结构是这种重复结构最好的实现方式。的确，研究这种Users和Microposts资源早期的重复结构也是本章最初的动机。（我们将会明白写一个健壮的toy programe程序需要耗费相当多的精力、我将会在第11章再次见到microposts资源——其实我不想隔那么久。。。）。&lt;/p&gt;

&lt;h4&gt;2.3.1 Microposts初步探索&lt;/h4&gt;

&lt;p&gt;和Users资源一样，我们先用Rails generate Scaffold创建Microposts资源的基本结构（Scaffold脚手架），如图2.3所示的那样，我们也创建了数据模型。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rails generate scaffold Micropost content:string user_id:integer
          invoke  active_record
          create    db/migrate/20100615004429_create_microposts.rb
          create    app/models/micropost.rb
          invoke    test_unit
          create      &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;/unit/micropost_test.rb
          create      &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;/fixtures/microposts.yml
           route  resources :microposts
          invoke  scaffold_controller
          create    app/controllers/microposts_controller.rb
          invoke    erb
          create      app/views/microposts
          create      app/views/microposts/index.html.erb
          create      app/views/microposts/edit.html.erb
          create      app/views/microposts/show.html.erb
          create      app/views/microposts/new.html.erb
          create      app/views/microposts/_form.html.erb
          invoke    test_unit
          create      &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;/functional/microposts_controller_test.rb
          invoke    helper
          create      app/helpers/microposts_helper.rb
          invoke      test_unit
          create        &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;/unit/helpers/microposts_helper_test.rb
          invoke  stylesheets
       identical    public/stylesheets/scaffold.css
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可能注意到了，在这个控制器中已经有几个action存在。Index，show，new，和edit等几个action对应第2.2.1中提到的页面，但是同时还有附加的create，update和destroy三个方法，通常这三个方法是不会去产生页面（并不绝对），相反，他们的主要作用是去修改数据库中User的信息。如表2.2所示，这基本是一个控制器的所有action，表中还显示了，Rails的REST运用。从表中看，有的URL是重复的，例如，控制器的show和update方法对应URL：“/users/1”，不同之处只是两者之间响应的HTTP请求方式不同。我们将在第3.2.2中详细学习HTTP请求方式。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;table class=&quot;bbcode&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;HTTP 请求方式&lt;/td&gt;&lt;td&gt; URL&lt;/td&gt;&lt;td&gt;    Action&lt;/td&gt;&lt;td&gt; 目的&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GET&lt;/td&gt;&lt;td&gt;    /users  &lt;/td&gt;&lt;td&gt;index  &lt;/td&gt;&lt;td&gt;请求一个用于列出所有用户的页面&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GET&lt;/td&gt;&lt;td&gt;    /users/1    &lt;/td&gt;&lt;td&gt;show   &lt;/td&gt;&lt;td&gt;请求显示id为1的用户的页面&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GET&lt;/td&gt;&lt;td&gt; /users/new&lt;/td&gt;&lt;td&gt;new  &lt;/td&gt;&lt;td&gt;请求创建用户的页面&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;POST&lt;/td&gt;&lt;td&gt; /users  &lt;/td&gt;&lt;td&gt;create &lt;/td&gt;&lt;td&gt;根据前面表单中的信息，向数据库创建用户&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GET&lt;/td&gt;&lt;td&gt;    /users/1 &lt;/td&gt;&lt;td&gt;edit  &lt;/td&gt;&lt;td&gt;请求编辑id为1的用户的页面&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PUT&lt;/td&gt;&lt;td&gt; /users/1 &lt;/td&gt;&lt;td&gt;update    &lt;/td&gt;&lt;td&gt;将更新的信息更新到数据库&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DELETE&lt;/td&gt;&lt;td&gt;  /users/1    &lt;/td&gt;&lt;td&gt;destroy    &lt;/td&gt;&lt;td&gt;删除数据库中id为1的用户&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;\       表2.2 Listing 2.2 中提供的用户资源的RESTful架构的路由&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;BOX 2.2
&lt;strong&gt;REpresentational State Transfer (REST)表述性状态转移&lt;/strong&gt;
如果你阅读了很多关于Ruby on Rails的阅读材料，你就会发现有很多地方提到“REST”（表述性状态转移的简写）REST是一种开发分布式应用例如网络应用程序例如web程序的一种架构。
REST原始的很抽象的，具体到Rails下的REST应用就是指大部分程序的组件（例如上文的users,microposts）都是可以视为资源，都是可以被创建，读取，更新和删除，这几&amp;gt;个动作就是关系数据库常说的CRUD操作和四个基本的HTTP请求方式：POST，GET，PUT和删除。（我们将在第3.2.2，特别是Box3.1更详细的学习）；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;作为一个Rails运用程序的开发人员来说，RESTful的开发方式有助于知道写哪个控制器和哪个action，你可以使用资源的CRUD构造程序的简单结构。在上面的users，microposts中，只要他们是你权限范围内的资源，你都可以直接的CRUD。在12章中，我们将看到一个例子，REST原则允许我们自然方便地塑造一个微妙的问题，“following users”。&lt;/p&gt;

&lt;p&gt;检查user控制器和user模型之间的关系，让我们来看看精简版本的index 方法（action翻译成方法。）吧。如下代码2.4（listing 翻译成代码。前面的就不去改了）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码2.4 演示程序中user简化版的index方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UsersController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ApplicationController&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;
    &lt;span class=&quot;vi&quot;&gt;@users&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;all&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在index方法中有 @users = User.all，这是告诉User模型去数据库检索出所有的用户，并把值赋给@users变量（发音“at-users”），User模型的代码如下2.5所示。尽管他非常的简单，但是它却有着非常牛B的功能，因为它继承了那个东西（可见2.3.4节和4.4）。特别是，因为使用Rails的Actuve Record库，下面的代码已经可以接受User.all来返回所有的用户了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码2.5. 演示程序的user模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby app/models/user.rb
    class User &amp;lt; ActiveRecord::Base
    end
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;一旦@users被定义（赋值）之后，控制器就可以条用视图（View），如代码2.6。以“@”符号开始的变量成为类变量，可以自动的在视图中调用，在这里，index.html.erb（代码2.6）中的游标将会遍历@users数组变量然后为每一项输出一串HTML代码。&lt;/p&gt;

&lt;p&gt;** 代码2.6. 用户index的视图(现在你不明白没关系。) **&lt;/p&gt;

&lt;p&gt;``` ruby app/views/users/index.html.erb
    &lt;h1&gt;Listing users&lt;/h1&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;table&amp;gt;
  &amp;lt;tr&amp;gt;
    &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
    &amp;lt;th&amp;gt;Email&amp;lt;/th&amp;gt;
    &amp;lt;th&amp;gt;&amp;lt;/th&amp;gt;
    &amp;lt;th&amp;gt;&amp;lt;/th&amp;gt;
    &amp;lt;th&amp;gt;&amp;lt;/th&amp;gt;
  &amp;lt;/tr&amp;gt;

&amp;lt;% @users.each do |user| %&amp;gt;
  &amp;lt;tr&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;%= user.name %&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;%= user.email %&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;%= link_to &amp;#39;Show&amp;#39;, user %&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;%= link_to &amp;#39;Edit&amp;#39;, edit_user_path(user) %&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;%= link_to &amp;#39;Destroy&amp;#39;, user, :confirm =&amp;gt; &amp;#39;Are you sure?&amp;#39;,
:method =&amp;gt; :delete %&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;/tr&amp;gt;
&amp;lt;% end %&amp;gt;
&amp;lt;/table&amp;gt;

&amp;lt;br /&amp;gt;

&amp;lt;%= link_to &amp;#39;New User&amp;#39;, new_user_path %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;这个视图将会被转换成HTML然后传回给浏览器，显示给用户。

####2.2.3 当前用户资源的缺陷


初步了解了Rails生成用户资源的优势之后，我们也该知道，他目前存在着不少的缺陷；

* 没有数据验证：模型接受一些非法的数据，例如空名字，不合法的email地址等。没有反馈
*  没有认证：没有登录/退出的概念，这样我们就没办法阻止随便一个用户操作某些操作。
* 没有测试：其实这不是非常准确，因为scaffolding会自己产生一些测试，但是生成的测试难看且死板，他们不会测试上面说的那2点或者其他用户自定义的一些需求。
 * 没有布局：没有一致的网站风格和导航。
* 还没有正理解：其实你要是真的理解了scaffold的代码，你或许就不会来看这本书。

###2.3 Microposts资源

在生成和探索了Users资源之后，让我们转过来看看另一个相关资源——Microposts。
在这一节中，我建议对比一下2个资源中相似的元素。你会看到2个资源之间会有很多地方都是相同的。Rails程序的RESTful结构是这种重复结构最好的实现方式。的确，研究这种Users和Microposts资源早期的重复结构也是本章最初的动机。（我们将会明白写一个不是toy programe的健壮程序需要耗费相当多的精力、我将会在第11章再次见到microposts资源——其实我不想隔那么久。。。）。

####2.3.1 Microposts初步探索


和Users资源一样，我们先用Rails generate Scaffold创建Microposts资源的基本结构（Scaffold脚手架），如图2.3所示的那样，我们也创建了数据模型。

``` bash
    $ rails generate scaffold Micropost content:string user_id:integer
          invoke  active_record
          create    db/migrate/20100615004429_create_microposts.rb
          create    app/models/micropost.rb
          invoke    test_unit
          create      test/unit/micropost_test.rb
          create      test/fixtures/microposts.yml
           route  resources :microposts
          invoke  scaffold_controller
          create    app/controllers/microposts_controller.rb
          invoke    erb
          create      app/views/microposts
          create      app/views/microposts/index.html.erb
          create      app/views/microposts/edit.html.erb
          create      app/views/microposts/show.html.erb
          create      app/views/microposts/new.html.erb
          create      app/views/microposts/_form.html.erb
          invoke    test_unit
          create      test/functional/microposts_controller_test.rb
          invoke    helper
          create      app/helpers/microposts_helper.rb
          invoke      test_unit
          create        test/unit/helpers/microposts_helper_test.rb
          invoke  stylesheets
       identical    public/stylesheets/scaffold.css
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如第2.2节，我们需要运行数据库迁移migration来更新数据库并添加新的数据模型。
&lt;code&gt;bash
    $ rake db:migrate
    ==  CreateMicroposts: migrating ===============================================
    -- create_table(:microposts)
       -&amp;gt; 0.0023s
    ==  CreateMicroposts: migrated (0.0026s) ======================================
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们已经如第2.2.1节创建Users那样创建了Microposts。你或许猜到了，Scaffold 生成器也为Microposts更新了Rails的routes文件。如代码2.7。 和Users一样， 代码:“resources:microposts”的路由规则映射了URL和对应的Microposts控制器方法。如表2.3所示。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;代码2.7 新增了Microposts资源的Rails路由&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby config/routes.rb
    DemoApp::Application.routes.draw do
      resources :microposts
      resources :users
      .
      .
      .
    end
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;table class=&quot;bbcode&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;HTTP request&lt;/td&gt;&lt;td&gt;  URL&lt;/td&gt;&lt;td&gt;    Action&lt;/td&gt;&lt;td&gt; Purpose&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GET&lt;/td&gt;&lt;td&gt;   /microposts&lt;/td&gt;&lt;td&gt;    index&lt;/td&gt;&lt;td&gt;  page to list all microposts&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GET&lt;/td&gt;&lt;td&gt;   /microposts/1&lt;/td&gt;&lt;td&gt;  show&lt;/td&gt;&lt;td&gt;   page to show micropost with id 1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GET&lt;/td&gt;&lt;td&gt;  /microposts/new&lt;/td&gt;&lt;td&gt;    new&lt;/td&gt;&lt;td&gt;    page to make a new micropost&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;POST&lt;/td&gt;&lt;td&gt; /microposts&lt;/td&gt;&lt;td&gt;    create&lt;/td&gt;&lt;td&gt; create a new micropost&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GET&lt;/td&gt;&lt;td&gt;    /microposts/1/edit&lt;/td&gt;&lt;td&gt;edit&lt;/td&gt;&lt;td&gt;    page to edit micropost with id 1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PUT&lt;/td&gt;&lt;td&gt;  /microposts/1&lt;/td&gt;&lt;td&gt;  update&lt;/td&gt;&lt;td&gt; update micropost with id 1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DELETE&lt;/td&gt;&lt;td&gt; /microposts/1&lt;/td&gt;&lt;td&gt;  destroy&lt;/td&gt;&lt;td&gt;    delete micropost with id 1&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;表2.3 代码2.7中，microposts资源提供的RESTful路由。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Microposts控制器示意代码如代码2.8所示。和代码2.3相比，除了用icropostsController替换掉UsersController之外基本一样，这是RESTful架构在2者只运用的体现。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;代码2.8，Microposts的示意代码&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;``` ruby app/controllers/microposts_controller.rb
    class MicropostsController &amp;lt; ApplicationController&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;  def index
    .
    .
    .
  end

  def show
    .
    .
    .
  end

  def new
    .
    .
    .
  end

  def create
    .
    .
    .
  end

  def edit
    .
    .
    .
  end

  def update
    .
    .
    .
  end

  def destroy
    .
    .
    .
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;让我们在“/microposts/new”页面添加一些实际的microposts（微博），如图2.12

![pic](http://dl.iteye.com/upload/attachment/369972/05fd9922-276e-39eb-992f-71eb189f1162.png)

\                       图2.12 添加微博的页面（/microposts/new）

就这样子，建立一两条微博，注意user_id为1是为了对应在2.2.1节中建立的第一个用户。结果如2.13图所示

![pic](http://dl.iteye.com/upload/attachment/369978/cc2087d7-e57c-37d8-9aea-f923778d8d5f.png)

\                   图2.13 Microposts的index页面（/microposts）

####2.3.2 给微博真正的“微”


任何敢叫微博的帖子要对得起他的称呼就要意味着要限制他的长度。要实现这个约束条件在Rails中是非常容易——使用模型验证（validations of rails）。我们可以使用length这个验证条件来限制微博的最大长度为140个字符（学习 Twitter）。你需要用你的IDE或者文本编辑器打开app/models/micropost.rb填入如代码2.9所示的代码（这个验证的使用是rails3的特性，如果你之前有使用Rails2.3.X版本，你可以对比一下“validates_length_of”的用法）。
代码2.9 约束微博最大字符长度为140。

``` ruby app/models/micropost.rb
    class Micropost &amp;lt; ActiveRecord::Base
      validates :content, :length =&amp;gt; { :maximum =&amp;gt; 140 }
    end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码2.9看起来很神秘，不过不要紧,我们将在6.2节中学习更多的验证，但是如果我们回到New页面然后输入超过140个字符的微博就会发现他的影响已经出来了；Rails会渲染错误的信息并提示微博的内容过长（我们将在第8.2.3中学习更多的错误。）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dl.iteye.com/upload/attachment/369988/7a511f79-f186-36d6-a3d7-73903ceeef16.png&quot; alt=&quot;p&quot;&gt;&lt;/p&gt;

&lt;p&gt;图2.14：创建微博失败的错误信息&lt;/p&gt;

&lt;h4&gt;2.3.3 一个user可以有多条微博&lt;/h4&gt;

&lt;p&gt;在两个不同的数据模型中创建关系是Rails最强大的功能之一。这里，用户模型中，每一个用户都可以多条的微博信息，我们可以如代码2.10和2.11那样更新User和Microposts模型的代码；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码 2.10. 一个user可以有多条微博信息microposts&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby app/models/user.rb
    class User &amp;lt; ActiveRecord::Base
      has_many :microposts
    end
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码 2.11 每一条微博信息都是属于某一个用户的&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;  ruby app/models/micropost.rb
    class Micropost &amp;lt; ActiveRecord::Base
      belongs_to :user

      validates :content, :length =&amp;gt; { :maximum =&amp;gt; 140 }
    end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以想象以上的关系就如图2.15所示。因为microposts表中有user_id的字段，Rails（使用Active Record）可以猜测出微博信息microposts和用户的关系&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dl.iteye.com/upload/attachment/369992/c4c778f3-2b27-30c9-94e5-9cc21b404060.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 2.15： 微博信息microposts和用户users之间的关系&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在第11，12章中，我们将用这2者间的关系来显示所有用户的microposts信息和构建一个和Twitter类似的微博提要（microposts feed）。现在我们通过Rails的控制台（console）来验证user和microposts之间的关系，控制台是一个非常有用的工，他可以使我们和Rails程序之间进行交互。我们先从命令行输入“rails console”进入控制台，然后使用User.first从数据库检索出第一个user（将 结果赋值给变量first_user）；&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rails console
    &amp;gt;&amp;gt; &lt;span class=&quot;nv&quot;&gt;first_user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; User.first
    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;gt; &lt;span class=&quot;c&quot;&gt;#&amp;lt;User id: 1, name: &amp;quot;Michael Hartl&amp;quot;, email: &amp;quot;michael@example.org&amp;quot;,&lt;/span&gt;
    created_at: &lt;span class=&quot;s2&quot;&gt;&amp;quot;2010-04-03 02:01:31&amp;quot;&lt;/span&gt;, updated_at: &lt;span class=&quot;s2&quot;&gt;&amp;quot;2010-04-03 02:01:31&amp;quot;&lt;/span&gt;&amp;gt;
    &amp;gt;&amp;gt; first_user.microposts
    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#&amp;lt;Micropost id: 1, content: &amp;quot;First micropost!&amp;quot;, user_id: 1, created_at:&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;2010-04-03 02:37:37&amp;quot;&lt;/span&gt;, updated_at: &lt;span class=&quot;s2&quot;&gt;&amp;quot;2010-04-03 02:37:37&amp;quot;&lt;/span&gt;&amp;gt;, &lt;span class=&quot;c&quot;&gt;#&amp;lt;Micropost id: 2,&lt;/span&gt;
    content: &lt;span class=&quot;s2&quot;&gt;&amp;quot;Second micropost&amp;quot;&lt;/span&gt;, user_id: 1, created_at: &lt;span class=&quot;s2&quot;&gt;&amp;quot;2010-04-03 02:38:54&amp;quot;&lt;/span&gt;,
    updated_at: &lt;span class=&quot;s2&quot;&gt;&amp;quot;2010-04-03 02:38:54&amp;quot;&lt;/span&gt;&amp;gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们通过first&lt;em&gt;name.microposts获得了用户的微博信息：运行这个代码，Active Record 会自动返回所有user&lt;/em&gt;id等于first_name的id（这里是1）。
我们将在11,12章中学习ActiveRecord的更多关联结构。&lt;/p&gt;

&lt;h4&gt;2.3.4 继承的层次结构&lt;/h4&gt;

&lt;p&gt;我们结束关于演示程序的讨论，我们花点时间，简短的介绍一下Rails中控制器类和模型类的继承问题。这个介绍只有在你有面向对象编程经验的时候才会有较多的意义。如过你还没学习OOP，大可以跳过这一节，特别是，你对类（在第4.4节中讨论）很不了解的时候，我建议在以后的时间跳回来看这一节。
我们先从模型的继承结构开始。对比代码2.12和代码2.13，我们可以看到，User和Micropost两个模型都从ActiveRecord：：Base类继承（通过尖括号“&amp;lt;”）。
ActiveRecord：：Base类是ActiveRecord提供的模型的基类。图2.16总结了这种关系；正式由于这种继承使我们的模型可以喝数据库交互，也可以将数据表的字段当成Ruby的属性对待，等等特性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码 2.12 继承的User类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby app/models/user.rb
    class User &amp;lt; ActiveRecord::Base
      .
      .
      .
    end
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码 2.13 继承的Micropost类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;``` ruby app/models/micropost.rb
    class Micropost &amp;lt; ActiveRecord::Base
      .
      .
      .
    end&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;![pic](http://dl.iteye.com/upload/attachment/370008/2119f47d-4fa9-3c59-9707-4a25863846b9.png)


控制器继承的层次结构较复杂一点。对比代码2.14和代码2.15，我们可以看到两个控制器都从ApplicationController。从代码2.16中可以看到ApplicationController自己继承自ApplicationController::base;这个是Rails的Acton Pack 库提供给控制器的基类，类之间的关系如图2.17所示。


**代码 2.14. UsersController继承自ApplicationController.**

``` ruby app/controllers/users_controller.rb
    class UsersController &amp;lt; ApplicationController
      .
      .
      .
    end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;代码 2.15. MicropostsController 继承自ApplicationController.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby app/controllers/microposts_controller.rb
    class MicropostsController &amp;lt; ApplicationController
      .
      .
      .
    end
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby app/controllers/application_controller.rb
    class ApplicationController &amp;lt; ActionController::Base
      .
      .
      .
    end
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://dl.iteye.com/upload/attachment/370012/d53669cd-bc2a-3da3-91ad-6eb7e004518a.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;\                       图 2.17: Users和Microposts控制器的继承结构.&lt;/p&gt;

&lt;p&gt;就和模型的继承一样，因为最终都继承自 ActionController::Base ，Users和Microposts的控制都获得大量的功能，比如操作模型对象，过滤收到的请求和渲染HTML页面。因为所有的控制都继承自ApplicationController，所以所有定义在Application Controller 里面的规则都会被自动的运用到所有的方法（action）中去；例如在8.2.4节中我们将看到如何在Application controller中定义一个允许我们从所有的Rails 日志文件中过滤掉密码的规则，这样可以避免一些安全隐患。&lt;/p&gt;

&lt;h4&gt;2.3.5 部署演示程序&lt;/h4&gt;

&lt;p&gt;我们完成了Microposts资源，现在正是我们把他push到GitHub库的时候；&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git add .
    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git commit -a -m &lt;span class=&quot;s2&quot;&gt;&amp;quot;Done with the demo app&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你也可以把演示程序部署到Heroku：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;heroku create
    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git push heroku master
    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;heroku rake db:migrate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（如果上面的没有效果，你可以看看前面代码1.8，或许对你有帮助。）
请注意这里在heroku运行数据库迁移的最后一行代码，这是只是在heroku上创建user/micropost的数据模型。如果你希望吧数据也上传，你可以使用 data up命令。前提是你有taps这个gem：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;sudo&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; gem install taps
    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;heroku db:push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.4 总结
现在我们站在一个Rails 程序30000英尺远的地方观察他，这一章中按这个方法开发的演示程序有一些优势和一些主机缺点（不明白什么意思， a host of weaknesses。）&lt;/p&gt;

&lt;p&gt;优势&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;High-level overview of Rails  高水平的Rails概述&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Introduction to MVC    介绍了MVC&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;First taste of the REST architecture    第一次尝试REST架构&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Beginning data modeling    开始数据建模&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A live, database-backed web application in production    制作了一个在线的数据库支持的Web程序&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;弱点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;No custom layout or styling    没有布局或者样式&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;No static pages (like “Home” or “About”)    没有静态页面，比如首页&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;No user passwords    用户没有密码&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;No user images     用户没有图片&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;No signing in     没有登录&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;No security     不安全&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;No automatic user/micropost association    没有自动关联user/micropost&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;No notion of “following” or “followed”    没有 “following” or “followed”的概念.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;No micropost feed    没有微博提要&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;No test-driven development    没有测试驱动&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;No real understanding    还没弄明白&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://tutorial.railschina.org/rails%20%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B/2013/08/28/chapter-2</link>
                <guid>http://tutorial.railschina.org/rails%20%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B/2013/08/28/chapter-2</guid>
                <pubDate>2013-08-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>第一章 从零到部署自己的网站</title>
                <description>&lt;p&gt;开始翻译 &lt;a href=&quot;http://ruby.railstutorial.org/&quot;&gt;Ruby on Rails Tutorial&lt;/a&gt; 转载请注明出处与原作者 &lt;a href=&quot;http://ruby.railstutorial.org/&quot;&gt;Michael Hartl&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;欢迎来到跟我实例学 &lt;a href=&quot;http://ruby.railstutorial.org/&quot;&gt;Ruby on Rails&lt;/a&gt;教程. 这本书的目的是要成为“我如何开始做Ruby on Rails ？”的最佳答案。当你完成这个ror教程之后你将学会与开发部署你自己的网页.&lt;/p&gt;

&lt;p&gt;你可以在这里获取许多相关的资源例如书，博客，视频，另外，自从ruby on rails 教程使用了rails3，你也将会在这里学到全套的最新最强大的rails 3版本。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;ruby on rails教程与许多别的rails教程书一样，通过构建许多小的简易程序来学习web开发。
与&lt;a href=&quot;http://sivers.org/&quot;&gt;Derek Sivers&lt;/a&gt;在前面提到的一样。这本书的构架会和一篇平铺的小故事一样，期望读者们能从头一篇篇的看到尾。如果你习惯跳跃性的阅读技术书记，你可能需要用一些不同的方法来读这篇教程，下面的这个引导段落可能对你有所帮助。你可以把&lt;strong&gt;ruby on rails 教程&lt;/strong&gt;当作一个电子游戏，把你自己当成游戏的主角，然后在这篇教材中快乐的打怪升级。。。（这些练习都是小boss … ^_^ ）&lt;/p&gt;

&lt;p&gt;在第一章，我们将会从安装ruby on rails的必须程序开始，同时设定我们的开发环境，之后我们会创建我们的第一个rails工程，我们会把它用上GIT版本控制。之后不管你们信不信，在这章我们就直接把它部署到网上去。&lt;/p&gt;

&lt;p&gt;在第二章，我们将会制作第二个工程，做它的目的是为了展示rails的应用的基础特性。为了快速开发部署，我们建立了了&lt;code&gt;demo app&lt;/code&gt;(名字是 demo_app）使用scaffolding脚手架来生成代码，——生成的代码又丑又复杂，第二章主要会关注它如何通过URLs和浏览器来浏览网页。&lt;/p&gt;

&lt;p&gt;在第三章，我们将会创建一个 sample application (名叫sample_app),这次的代码将会全部用scratch的方法生成。我们将会开发那个例程通过使用 测试驱动开发（TDD &lt;strong&gt;test-driven-development&lt;/strong&gt;）从第三章开始我们将会创建一个静态的页面，然后我们再加入一些动态的内容。我们将会在第四章走开一会，来关注一下rails底下Ruby语言特性。然后在第五章到第十章我们将会通过使用网页布局，用户数据库，全方位的注册和认证系统来完整的建立这个实例程序。最后在第十一章和第十二章我们将会加入微博和社会化特性来完成这个实例站点。&lt;/p&gt;

&lt;p&gt;最后这个实例程序将会与一个实实在在的流行的微博社交网站(twitter)十分相似，巧合的事，twitter也是用rails开发的。虽然我们一直在关注的是这个实实在在的示例站点，但是关键的是我们通过ruby on rails 教程将会学到许多通用的法则，这将会让你不管开发什么网站都一个扎实的基础。&lt;/p&gt;

&lt;blockquote&gt;
&lt;h4&gt;BOX1.1 scaffolding，一个快速，简洁诱人的脚手架&lt;/h4&gt;

&lt;p&gt;从一开始，rails就从这样明显的可操作性中受益良多。不管是rails创始人avid Heinemeier Hansson著名的&lt;a href=&quot;http://media.rubyonrails.org/video/rails_take2_with_sound.mov&quot;&gt;15分钟开发一个博客系统&lt;/a&gt;，还是后来升级之后的&lt;a href=&quot;http://media.rubyonrails.org/video/rails_blog_2.mov&quot;&gt;15分钟搭建博客系统by rails 2&lt;/a&gt;这些时评都是非常棒的办法去体会rails的强大，同时我也推荐你们去看看这些视频。但是我要警告你们：他们在15分钟奇迹般的完成这份工作使用一个叫做scaffolding脚手架的功能，它将迅速生成大量代码，用的是&lt;code&gt; rails generate &lt;/code&gt;命令。
然后回到我们的ruby on rails教程，如果我们在教程中过度依赖这个方法——虽然更快更简便更诱人，但是大量复杂而且固定的代码将会成为rails开发初学者不可逾越的障碍，你或许能够使用这个特性，但是但是你或许永远都不会明白它。
在ruby on rails 教程，我们将会使用几乎完全不同的方法。第二章我们将会用脚手架开发一个小的DEMO程序，但是本教程的核心仍然是第三章开始的sample app上。在每章开发sample app的过程中，我们都会生成一些短小的代码，这些代码能够让你更好的理解rails，你同样也能把它当作是一组挑战。这样循序渐进的方法能够给你一个rails学习的好环境让你更深刻，灵活的掌握rails。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;1.1介绍&lt;/h3&gt;

&lt;p&gt;自从ruby on rails 在2004年一鸣惊人之后迅速成为了最强大而流行的动态网络框架。rails帮助那些小用户迅速成长为了大型的公司，包括&lt;a href=&quot;http://posterous.com/&quot;&gt;Posterous&lt;/a&gt;, &lt;a href=&quot;http://uservoice.com/&quot;&gt;UserVoice&lt;/a&gt;, &lt;a href=&quot;http://shopify.com/&quot;&gt;37signals&lt;/a&gt;, &lt;a href=&quot;http://shopify.com/&quot;&gt;Shopify&lt;/a&gt;, &lt;a href=&quot;http://github.com/&quot;&gt;GitHub&lt;/a&gt;, &lt;a href=&quot;http://scribd.com/&quot;&gt;Scribd&lt;/a&gt;, &lt;a href=&quot;http://hulu.com/&quot;&gt;Hulu&lt;/a&gt;, &lt;a href=&quot;http://yellowpages.com/&quot;&gt;the Yellow Pages&lt;/a&gt;.
世界同样还有许多web开发网店精通于rails，例如&lt;a href=&quot;http://entp.com/&quot;&gt;ENTP&lt;/a&gt;, &lt;a href=&quot;http://thoughtbot.com/&quot;&gt;thoughtbot&lt;/a&gt;, &lt;a href=&quot;http://pivotallabs.com/&quot;&gt;Pivotal Labs&lt;/a&gt;, 和 &lt;a href=&quot;http://hashrocket.com/&quot;&gt;Hashrocket&lt;/a&gt;,当然还有无数的独立开发者，培训师，顾问，承包商也是如此。&lt;/p&gt;

&lt;p&gt;是什么让rails变得那么的强大？首先，ruby on rails是100%开源的，基于&lt;a href=&quot;http://www.opensource.org/licenses/mit-license.php&quot;&gt;MIT 认证&lt;/a&gt;,对于任何人都是完全免费下载使用的。rails的成功也归功与它优雅而紧密的设计，在其底层的ruby语言同样让人感到惊叹不已。rails为网站开发有效的创建了一个全新的&lt;a href=&quot;http://en.wikipedia.org/wiki/Domain_Specific_Language&quot;&gt;专属语言（domain-specific language）&lt;/a&gt;。许多常见的网络开发任务，例如生成HTML，使用数据库模型，生成网址路由，对于rails都是轻而易举的。更重要的是，最终的rails应用程序总是简洁而可读性强。&lt;/p&gt;

&lt;p&gt;rails同样适用于一个全新的网络框架与技术新手。举例来说，rails是第一个完整的使用digest实现REST网站构架的应用程序（我们很快就会在这篇教材里面学到了。）并且当其他框架拥有了新的功能的时候rails的开发者David Heinemeier Hansson和rails的核心小组绝不会对加入那些诱人的idea有任何的犹豫。其中最戏剧性的就是rails 和Merb的合并，（merb是另一个ruby网络框架）这样rails就拥有了merb中引入的更强大的模块设计，稳定的api和更佳的特性。&lt;/p&gt;

&lt;p&gt;最后，rails也从不同的社区中受益良多，其中包括了成百个开源的作者，热闹的讨论组，大量的插件和gems（包括了对某些特定问题的解决方案例如图片上传和分页设计），丰富多彩的博客和rails论坛和irc频道。大量的rails编程人员也在让解决那些应用程式问题变得更佳简单：“Google the error message”几乎总是能把你带到你最需要的那篇博客或者论坛上去。&lt;/p&gt;

&lt;h4&gt;对不同读者的建议&lt;/h4&gt;

&lt;p&gt;这个rails教程不但包括了rails，还有ruby，html，css以及一些javascript，甚至还有一点点的SQL。这意味着，不管你现在掌握了多少关于网络开发的知识，在你完成本教程之后你还是又必要阅读更多更高级的rails资源的，这样才能帮助你完成一个完整的网络开发知识体系。&lt;/p&gt;

&lt;p&gt;rails 很多时候会有一些看起来如同“魔法”一般的特性（例如直接就能够建立数据库表单项目）来完成一个一个的奇迹，但是实际上rails的构造更佳的神秘，这个ruby on rails教程并不准备具体戒指这些“魔法”——主要是作为一个rails开发者你并不需要彻底明白在这一层华丽的外边后面的工作机制（就如同ruby绝大部分使用C语言设计的，但是你没必要去研究ruby的源代码来使用ruby一样）。如果你是一个打破砂锅问到底的人。那么我建议你去读读Obie Fernandez写的The Rails 3 Way，你可以把它收藏起来，在学习这个教程的统一读一读。&lt;/p&gt;

&lt;p&gt;虽然本教程没有什么先决条件，但是你至少也应该有一些计算机经验。如果你连文本编辑器的使用经验都没有，那么恐怕你要学起来就会非常的困难。另一方面，即使你的 &lt;code&gt;.emacs&lt;/code&gt;文件复杂到成年人都想哭的地步的话这篇教材同样会有让你感到挑战的东西的。rails教程被设计成一个无论你的背景是什么都能够通过你自己独特的方法学到很多东西的东西。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于所有读者&lt;/strong&gt;：学习rails最常见的一个问题就是是否应该先去学ruby语言。这个答案取决与你的个人学习习惯。如果你通常会系统的去学习一个东西的话，那么从ruby学起应该会是很好的选择。这章里会有几本相当不错的书推荐给你看。另一方面，许多rails开发者都对制作网络应用相当感兴趣，同时他们不想在制作出一个web应用之前阅读500页的ruby手册。而且rails开发者所关注的知识恐怕你在纯粹的ruby书中是找不到的——但是在本教程中你能够轻松获取。我建议你从这个rails教程开始，然后去阅读纯粹的ruby语言书。我觉得这个并不是二选一的事情，而是——如果你上手了rails开发并且感觉你需要一些ruby的知识，，那么，你可以停下来看看ruby编程书，然后在你觉得OK了的时候重新上路。你可能会想通过网络中简短的教程尝试一下ruby编程。你可以在(http://www.ruby-lang.org/) 或者 (http://rubylearning.com/)找到你想要的。&lt;/p&gt;

&lt;p&gt;另外一个常见的问题是如何去运用测试。如果我在简介中提到的，rails教程使用了测试驱动的开发模式。
在我的观点里，这是最好的学习rails应用的方法。但是测试的确让你付出大量的时间。如果你发现发现你被这些测试程序困住了，那么你可以考虑在你第一次阅读这本书的时候跳过它。事实上，许多的读者将会教程中穿插着各种——测试，版本控制，部署——会让你刚开始让你有点喘不过气。如果你发现你为他们感到十分的烦躁，那么你应该毫不犹豫的放弃它，虽然我只加入了专业开发者最最精华的部件，但是对于你来说能够完成rails教程的核心代码才是最重要的 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于非设计师的新手开发人员&lt;/strong&gt;：rails教程并不假设你有任何的计算机背景，但是如果你又一些计算机语言的学习经验你会更快的上手。请时刻记住，这只是你在web开发学习中的第一步，web开发还有许多诱人的部分，包括HTML/CSS，javascript，数据库（包括sql），版本控制和部署。这本书将会介绍关于他们的一点，但是你要走的路还很长。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于新手的网页设计师&lt;/strong&gt;：你的设计技能对学习rails帮助很大。因为你基本上了解了HTML和CSS/在完成这本书之后你将会成为一个更佳成功的设计师，并且你就拥有了独自开发网站的资本。你可能发现了编程方面的困难，但是ruby开发语言对于新手来说是非常非常友好的，尤其是那些神奇的单复数～&lt;/p&gt;

&lt;p&gt;在完成这个ruby on rails教程之后，我建议编程新手阅读《&lt;a href=&quot;Beginning%20Ruby&quot;&gt;Beginning Ruby&lt;/a&gt;
》by Peter Cooper.这书基本和本教材保持了一致的结构。我同样建议你阅读&lt;a href=&quot;http://www.amazon.com/gp/product/0672328844/ref=as_li_ss_tl?ie=UTF8&amp;amp;tag=httpwwwrailst-20&amp;amp;linkCode=as2&amp;amp;camp=217145&amp;amp;creative=399369&amp;amp;creativeASIN=0672328844&quot;&gt;The Ruby Way &lt;/a&gt;
最后作为一个资深的rails开发者我觉得你还应该阅读 《The Rails 3 Way》 by Obie Fernandez.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于网络开发来说&lt;/strong&gt;，即使是一个看起来简单的小应用也会做起来很复杂。如果你确实对于web编程感到头疼并却感觉这个教材是那么的无法逾越。那么恐怕你还没又做好网站制作的准备。你最好多学学HTML和CSS然后在开始这个教程。（不好意思，我并没有什么关于HTML的个人推荐，但是《Head First HTML》貌似值得一学，关于CSS你可以尝试：《CSS ：THE MISS MANUAL》by David Sawyer McFarland）。我也推荐你先去阅读一下《Beginning Ruby》的前几章，那些短小的程序可以让你迅速找到感觉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于web开发新手但是经验丰富的编程人员&lt;/strong&gt;：你的经验可能已经帮助你明白了像：类，方法，数据结构的概念。这是你的优势。另外如果你原先用的是C++或者java，你可能发现Ruby a bit of an odd duck(估计是有点讨厌的意思。。。)。你可能需要一些时间来适应它。常用ruby，你将会适应并且喜欢上它的。（Ruby 甚至同意让你在句末加上分号。。。）Rails Tutorial 包含了所有的web专有概念，所以如果你不懂&lt;strong&gt;PUT&lt;/strong&gt;和&lt;strong&gt;POST&lt;/strong&gt;你可以完全不用担心。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于有经验的ruby程序员&lt;/strong&gt;：作为一个ruby程序员你不会rails实在是太不正常了，但是如果你确实是这样的一个另类的精英。我建议你可以跳过这个教材直接阅读《The Rails 3 Way》by Obie Fernandez.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于有经验的rails开发人员：&lt;/strong&gt;这个教材对你完全是多余的。但是许多经验丰富的rails开发者也能同样在这本教材中寻找到惊喜～所以我想你会喜欢对于本教材的独特视角的。&lt;/p&gt;

&lt;p&gt;在阅读完本教材之后我建议那些有经验的程序员阅读《The Well-Grounded Rubyist》by David A. Black，它从底层深入讨论了ruby，或者《The Ruby Way 》by Hal Fulton,同样一本高级ruby书，然后你可以接着看《The Rails 3 Way》来做一些更深入的rails练习。&lt;/p&gt;

&lt;p&gt;总而言之，无论你从哪里开始，你都应该关注一些更深入更直接的rails支援，这些是我有参加的一些参考：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://railscasts.com/&quot;&gt;Railscasts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://peepcode.com/&quot;&gt;PeepCode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://guides.rubyonrails.org/&quot;&gt;Rails Guides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.google.com/search?q=ruby+on+rails+blogs&quot;&gt;Rails blogs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;1.1.2 “Scaling”(谁知道怎么翻译？)的rails&lt;/h4&gt;

&lt;p&gt;在开始我们的教程之前我想要花一点时间来纠正一个多年来关于rails框架的最常见的问题：rails能不能去“架构“一个大型网站。我觉得关于这个问题你们有一些误区：&lt;a href=&quot;http://idleprocess.wordpress.com/2009/11/24/presentation-summary-high-performance-at-massive-scale-lessons-learned-at-facebook/&quot;&gt;你架构的是一个网站，不是一个框架&lt;/a&gt;.而rails再牛逼也就是一个框架而已。所以你们真正想问的恐怕应该是：“大流量的网站能够用否rails框架来搭建？“。而如今，我想这个问题应该能够被很确定的回答：世界上某些流量最大的网站就是用rails搭建的！实施上做一个架构需要的东西远远不只是rails但是如果你确定你能够作出一个像Hulu,Yellow Pages那样的大型网站的话，我想rails是不会阻止你去颠覆世界的～！&lt;/p&gt;

&lt;h4&gt;1.1.3 关于本书的标准约定&lt;/h4&gt;

&lt;p&gt;本书的约定我基本上都会在提出之前解释清楚。这里先说清楚一点：&lt;/p&gt;

&lt;p&gt;不管是PDF还是HTML格式的这份教程都是充满链接的，包括了内部和外部链接，就像&lt;a href=&quot;http://rubyonrails.org/download&quot;&gt;Ruby on Rails download&lt;/a&gt;一样。&lt;/p&gt;

&lt;p&gt;关于本书的当中的命令行：为了简便，所有命令行我都用类Unix风格的提示符来表示，例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ echo &amp;quot;hello,world&amp;quot;
hello,world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Windows下的用户你可能会出现类似的的命令和命令提示符:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;C：\Sites&amp;gt;echo hello,world
hello,world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在类Unix系统中一些命令需要执行&lt;code&gt;sudo&lt;/code&gt;命令，它指的是“代替用户执行”。默认情况下这个命令将会让你以管理员权限运行自己的用户，它能让你更改和访问一些普通用户无法读写的文件，例如&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ sudo ruby setup.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大部分的Unix/Linux/OS X系统需要加上一个&lt;code&gt;sudo&lt;/sudo&gt; 命令，除非你使用了Ruby的版本管理软件（在1.2.2.3介绍）。如果这样的话你将可以这样运行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ ruby setup.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Rails现在也可以作为一个命令来运行了,例如我们在1.2.5就会运行一个本地的web开发服务器运用到如下的命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rails server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与命令提示符一样，Rails Tutorial使用了类Unix方式的地址分割栏（/）。我的Rails Tutorial应用就在我计算机中的&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;/Users/mhartl/rails_orojects.sample_app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面。在windows例，同样的目录就会变成&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;C:\Sites\sample_app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有我所说的“根目录”说的都是rails开发根目录，从今以后所有的目录都会相对与这个地址表示。例如我说&lt;code&gt;config&lt;/code&gt;目录说的就是&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;/Users/mhartl/rails_projects/sample_app/config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个加上config的目录。同样，如果我表示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;/Users/mhartl/rails_projects/sample_app/config/routes.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我会简写成&lt;code&gt;config/routes.rb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;最后，Rails Rutorial 常常会输出不同的程序和文件，由于不同的计算机系统可能大家看到的又些许区别，但是这没有问题。另外，有意写命令可能由于你的计算机系统会产生错误信息，与其去一点一点的分析&lt;a href=&quot;http://en.wikipedia.org/wiki/Sisyphus&quot;&gt;Sisyphean&lt;/a&gt;错误日志，我觉得直接&amp;quot;Google 一下&amp;quot;回事更好的方法，这也将成为你在实践部署中的宝贵经验。&lt;/p&gt;

&lt;h3&gt;1.2   让它跑起来&lt;/h3&gt;

&lt;p&gt;是时候开始搭建我们的Ruby on Rails 开发环境了，同时我们会作出我们的第一个应用。刚开始可能有点难，尤其是对于毫无编程经验的人们来说，但是千万别在现在就灰心了。不仅仅是你，任何一个程序员都会经历这样的时刻的。&lt;/p&gt;

&lt;h4&gt;1.2.1 开发环境&lt;/h4&gt;

&lt;p&gt;考虑到大家不同的环境和习惯，可能一万个开发者就有一万种开发环境，但是归根结底可能就两种：文本编辑器和集成开发环境（IDE）。关于后者：&lt;/p&gt;

&lt;p&gt;IDEs&lt;/p&gt;

&lt;p&gt;rails并不缺少支持 rails 的 IDE，有：&lt;a href=&quot;http://www.aptana.com/rails/&quot;&gt;RadRails&lt;/a&gt; , &lt;a href=&quot;http://www.jetbrains.com/ruby/index.html&quot;&gt;RubyMine&lt;/a&gt; 和 &lt;a href=&quot;http://www.codegear.com/products/3rdrail&quot;&gt;3rd Rail&lt;/a&gt; .所有这些都是跨平台的，我还听说了他们的一些很棒的功能，我建议你去尝试一下他们看看你用的舒服不舒服。我从来不觉得IDE适用与大部分的rails开发者，至少对我来说，我从来没有用过他们&lt;/p&gt;

&lt;p&gt;文本编辑器和命令行&lt;/p&gt;

&lt;p&gt;如果不用IDE那还能用什么开发rails呢？我想大部分的开发者会和我的选择一样：用文本编辑器来编辑rails代码，用命令行去让rails跑起来。具体用什么我想这个取决与你使用的平台：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Machintosh OS X：和许多rails开发者一样，我推荐 &lt;a href=&quot;http://macromates.com/&quot;&gt;TextMate&lt;/a&gt;.另一个选择是 &lt;a href=&quot;www.gnu.org/s/emacs/&quot;&gt;Emacs&lt;/a&gt; 和 MacVim（这是一个相当不错的vim的mac定制版）。我用 iTerm 来作为我的命令行终端，用自带的终端当然也没问题。&lt;/p&gt;

&lt;p&gt;Linux ：你的文本编辑器可能和 OS X 下的基本一直，除了没有了TextMate。。。我建议你使用图形界面的 gVim ，或者是带上 GMate 插件的 gedit 。或者 Kate 也行.命令行的话。。目前我还没有听说有哪个linux的发行般会没有带终端程序。&lt;/p&gt;

&lt;p&gt;Windows :推荐的 Windows 文本编辑器有： Vim ， &lt;a href=&quot;http://www.e-texteditor.com/&quot;&gt;E Text Editor&lt;/a&gt; , &lt;a href=&quot;http://www.activestate.com/komodo_edit/&quot;&gt;Komodo Edit&lt;/a&gt; 还有 &lt;a href=&quot;http://www.sublimetext.com/&quot;&gt;Sublime Text&lt;/a&gt;.对于命令行，我建议使用 Rails Installer 自带的 命令行 程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你的选择是Vim，那么我建议你去好好看看 &lt;a href=&quot;http://www.google.com/search?q=vim+rails&quot;&gt;Vim-using Rails hackers&lt;/a&gt; 。尤其是 &lt;a href=&quot;http://www.vim.org/scripts/script.php?script_id=1567&quot;&gt;rails.vim&lt;/a&gt; 和 &lt;a href=&quot;http://www.vim.org/scripts/script.php?script_id=1567&quot;&gt;NERDTree&lt;/a&gt; 增强插件。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;                                图1.1 : TextMate/iTerm 下的文本编辑器。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/editor_shell.png&quot; alt=&quot;http://ruby.railstutorial.org/images/figures/editor_shell.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;浏览器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;虽然你有许许多多的浏览器可以选择，但是大部分的rails开发者来说他们用的都是 &lt;a href=&quot;http://getfirebug.com/&quot;&gt;Firefox&lt;/a&gt; ,Safari ,和 Chrome 来进行开发。这份教材的rails截图都将来自与 FireFox。另外，如果你也用 &lt;a href=&quot;http://getfirebug.com/&quot;&gt;Firefox&lt;/a&gt; 那么我强烈建议你用 Firebug 火狐插件。这可一让你的平台神奇的把所有的 HTML 和 CSS 语法都展现在你的页面上。 对于那些不用火狐的人来说 Firebug Lite 也对大部分浏览器有效。另外对于 大部分浏览器，包括 Safiri 和 Chrome 都有在右键内嵌的 “Inspect element” 功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于工具的注意事项&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在开动我们的开发之前，你可能要花费很多时间在准备工作上。学着使用编辑器和IDE是一件漫长的事情——我是说你完全可以在 TextMate 和 Vim 上琢磨上一个星期。如果你是一个新手，那么我希望你能 坚持的使用这些工具，每个人都有这个过程。虽然有时候这让人沮丧，虽然当你脑子里面又一个超级cool的点子和设计的时候 却只能坐在这里学 rails 的工具很烦，但是我想花一个星期去琢磨你的文本编辑器会使一个划得来的交易。去理解那些工具，他会给你带来奇迹般的效率的。&lt;/p&gt;

&lt;h4&gt;1.2.2 Ruby,RubyGems,Rails 还有 Git&lt;/h4&gt;

&lt;p&gt;现在时候来安装 ruby 和 rails 了。最中规中矩的做法是去 &lt;a href=&quot;http://rubyonrails.org/download&quot;&gt;Ruby on Rails download page&lt;/a&gt; 找一份最新的然后下下来装上。哪里听不错的，有不少可以离线阅读的图书和资源下载，但是在这里我会推荐以下方法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rails Installer (Windows)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在 Windows 上安装rails实在不是一件令人舒服的事情，但是感谢那些 Engine Yard 的好人们————尤其是 Dr. Nic Williams 和 Wayne E. Seguin————现在在windows安装ruby on rails 现在变得轻松无比。如果你正在使用 windows 直接下载 &lt;a href=&quot;http://rubyforge.org/frs/download.php/75114/railsinstaller-1.3.0.exe&quot;&gt;Rails Installer&lt;/a&gt; 下载安装 Rails Installer 并且双击执行，这里还会直接打包好Git版本控制软件，所以你是可以跳过这整个安装步骤啦！你可以直接在1.2.3开始看我们的第一个Ruby应用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装 Git&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;许多rails开发包用git版本控制软件进行管理。因为这种情况很普遍，所以我建议你也应该尽早的上手去学学git，我推荐这里的一份git安装与命令手册 &lt;a href=&quot;http://progit.org/book/ch1-4.html&quot;&gt;Installing Git section of Pro Git&lt;/a&gt; .&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装 Ruby&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下一步就是安装Ruby了，你的计算机里面可能已经有Ruby了，你可以运行.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ ruby -v
ruby 1.9.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来确认你的版本号。Rails需要Ruby1.8.7以上才能工作，推荐版本为1.9.2。这份教材假设大家使用的是1.9.2的版本，不过如果你用的是1.8.7的版本也没什么问题。另外，Windows用户在安装 Rails Installer 1.3.0 会默认搭配上 ruby 1.8.7 。&lt;/p&gt;

&lt;p&gt;Ruby 1.9 作出了非常多的改动，所以你想要直接用上最新的Ruby或许有意写困难，如果你喜欢总是能用上最新版本的指令的话，下面的不走是我推荐的于是我现在所使用的方法（在 macintosh OS X上），你可以在网络上找到和你系统配套的命令。&lt;/p&gt;

&lt;p&gt;首先要声明的事，我还是建议你使用 OS X 或者 Linux ，在这两个系统上我强烈推荐你使用 &lt;a href=&quot;http://rvm.beginrescueend.com/&quot;&gt;Ruby版本管理器 RVM&lt;/a&gt; 来安装管理你的Ruby版本。如果你想在同一机器上运行 Rails 3 和 Rails 2 这是非常重要的，在这里我给出的建议是,安装两套 RoR 版本: Ruby 1.8.7/Rails 2.3 和 Ruby 1.9.2/Rails 3.如果你在运行或者安装RVM的时候出现了问题，你可以在RVM的IRC 频道找到 Wayne E.Swguin报告问题。&lt;/p&gt;

&lt;p&gt;在安装了RVM之后你需要的只是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rvm get head
$ rvm reload
$ rvm install 1.8.7
$ rvm install 1.9.2
&amp;lt;wait a while&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前两个命令行是让RVM将自己升级并且重新加载的，RVM的更新很快，升级一下是一个好习惯。后面两个命令将会花一些时间下载和编译程序，如果它看上去好像死机，不要担心的太多，他会装好的。（有时候你可能需要在安装的版本号后面加上一个“补丁号”才可以让你正确的安装，例如你想要302版本的补丁可以&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rvm install 1.8.7-p302
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ruby程序通常通过 gems 分布式的进行管理，gems 包自己也包含着Ruby代码，如果你的gems会因为不同版本的Ruby而冲突，建立不同的 gemets 来管理gems是一个不错的选择。需要指出的是，rails也是一个gem包，而且rails 2 和rails 3 就是互相冲突的。所以如果你需要在同一个系统上面运行不同版本的rails你可以这样来创立两个不同的 gemset ：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rvm --create 1.8.7-p302@rails2tutorial
$ rvm --create use 1.9.2@rails3tutorial
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中第一个命令创立了gem包管理集合 rails2tutorial ，关联到Ruby 1.8.7-P302 ，第二个命令行是把 gem包管理集合 rails3tutorial关联到 1.9.2版本上去，并且开始使用（通过 use 命令），另外，RVM 还支持多样化的包管理操作，你可以这个文档里看到具体操作：(http://rvm.beginrescueend.com/gemsets/).&lt;/p&gt;

&lt;p&gt;在教程里我们会用到 ruby 1.9.2 + Rails3 进行开发。所以你可以这样来配置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rvm --default use 1.9.2@rails3tutorial
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这条命令同时设置的默认的 Ruby 程序和 gem包集合rails3tutorial。&lt;/p&gt;

&lt;p&gt;如果你对RVM 感到疑惑的花运行下面这两个命令或许会给你带来帮助&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rvm --help
$ rvm gemset --help
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;安装RubyGems&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;RubyGems是Ruby项目的包管理程序，包含的上千个优秀应用（包括rails），Ruby包，Gem。你安装了Ruby之后安装RubyGems也很简单，如果你安装了RVM那么RubyGems将会被自动添加。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ which gem
/Users/mhartl/.rvm/rubies/ruby-head/bin/gem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你还没有，你可能需要下载 &lt;a href=&quot;http://rubyforge.org/frs/?group_id=126&quot;&gt;RubyGems&lt;/a&gt; , 你在这里可能需要 &lt;code&gt;sudo&lt;/code&gt; 命令.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ruby setup.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你已经有了 RubyGems 你可以用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ gem update --system 1.8.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;升级你的gem来保持与本教材的一致。如果你用的是 Ubuntu Linux 那么你可以在the Ubuntu/Rails 3.0 blog post by Toran Billups这里得到完整的安装帮助。&lt;/p&gt;

&lt;p&gt;当你安装gems的时候，RubyGems 就会生成两种不同的文档(叫做 ri 和 rdoc)，但是许多Ruby Rails开发者都发现建立这些文档的时间相当不值（因为很多程序员比较喜欢在线浏览他们需要的文档）。为了取消自动生成文档给你造成不必要的时间浪费我建议你在你的个人目录（home directory）下面的gem配置文件.gemrc加入一行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gem: --no-ri --no-rdoc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;安装Rails&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你装完RubyGems之后安装Rails就会很轻松，保持与本教材一致的版本只需要&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ gem install rails --version 3.0.11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;确认rails工作了你可以&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rails -v
Rails 3.0.11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;目前最新的rails版本是rails3.1 ，本教材使用rails3.0是出于rails3.0目前还是最稳定版本的原因，你可以自行决定何时更换你的rails版本。另外对于一个rails新手来说，rails3.0 和 rails 3.1 是十分相似的，所以大部分你所学到的东西能够兼容 rails 3.1。&lt;/p&gt;

&lt;p&gt;关于rails 3.1 的向后不兼容部分 与新特性你可以阅读第13章，我们会在那里会有简短的讨论和介绍。最后本书的rails 3.1版本的编写已经开始了，可能会加入一些新的特性（例如Sass 和 coffescript）.&lt;/p&gt;

&lt;h4&gt;1.2.3 第一个应用&lt;/h4&gt;

&lt;p&gt;Running the rails script to generate a new application.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ mkdir rails_projects
$ cd rails_projects
$ rails new first_app
      create
      create  README
      create  .gitignore
      create  Rakefile
      create  config.ru
      create  Gemfile
      create  app
      create  app/controllers/application_controller.rb
      create  app/helpers/application_helper.rb
      create  app/views/layouts/application.html.erb
      create  app/models
      create  config
      create  config/routes.rb
      create  config/application.rb
      create  config/environment.rb
      .
      .
      .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意rails创建的这些文件和文件夹，这些标准文件和文件夹的结构是一个rails的优点，它能够迅速的从零开始搭建应用程序。另外，因为这些文件夹文件的结构对于任何rails工程都是相同的，所以你可以迅速上手不同rails开发者的代码。rails默认生成的文章结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/directory_structure_rails_3.png&quot; alt=&quot;picture&quot;&gt;&lt;/p&gt;

&lt;p&gt;我们会在下面的学习中一一介绍这些文件和目录。&lt;/p&gt;

&lt;div class=&quot;table&quot;&gt;&lt;div class=&quot;center&quot;&gt;&lt;table class=&quot;tabular&quot;&gt;&lt;tr&gt;&lt;th class=&quot;align_left&quot;&gt;&lt;strong&gt;File/Directory&lt;/strong&gt;&lt;/th&gt;&lt;th class=&quot;align_left&quot;&gt;&lt;strong&gt;Purpose&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;tr class=&quot;top_bar&quot;&gt;&lt;td class=&quot;align_left&quot;&gt;&lt;tt&gt;app/&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;align_left&quot;&gt;Core application (app) code, including models, views, controllers, and helpers&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;align_left&quot;&gt;&lt;tt&gt;config/&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;align_left&quot;&gt;Application configuration&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;align_left&quot;&gt;&lt;tt&gt;db/&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;align_left&quot;&gt;Files to manipulate the database&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;align_left&quot;&gt;&lt;tt&gt;doc/&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;align_left&quot;&gt;Documentation for the application&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;align_left&quot;&gt;&lt;tt&gt;lib/&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;align_left&quot;&gt;Library modules&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;align_left&quot;&gt;&lt;tt&gt;log/&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;align_left&quot;&gt;Application log files&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;align_left&quot;&gt;&lt;tt&gt;public/&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;align_left&quot;&gt;Data accessible to the public (e.g., web browsers), such as images and cascading style sheets (CSS)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;align_left&quot;&gt;&lt;tt&gt;script/rails&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;align_left&quot;&gt;A script provided by Rails for generating code, opening console sessions, or starting a local web server&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;align_left&quot;&gt;&lt;tt&gt;test/&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;align_left&quot;&gt;Application tests (made obsolete by the &lt;tt&gt;spec/&lt;/tt&gt; directory in &lt;a class=&quot;ref&quot; href=&quot;static-pages#sec:static_pages_with_rails&quot;&gt;Section&amp;nbsp;3.1.2&lt;/a&gt;)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;align_left&quot;&gt;&lt;tt&gt;tmp/&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;align_left&quot;&gt;Temporary files&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;align_left&quot;&gt;&lt;tt&gt;vendor/&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;align_left&quot;&gt;Third-party code such as plugins and gems&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;align_left&quot;&gt;&lt;tt&gt;README&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;align_left&quot;&gt;A brief description of the application&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;align_left&quot;&gt;&lt;tt&gt;Rakefile&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;align_left&quot;&gt;Utility tasks available via the &lt;code&gt;rake&lt;/code&gt; command&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;align_left&quot;&gt;&lt;tt&gt;Gemfile&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;align_left&quot;&gt;Gem requirements for this app&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;align_left&quot;&gt;&lt;tt&gt;config.ru&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;align_left&quot;&gt;A configuration file for &lt;a href=&quot;http://rack.rubyforge.org/doc/&quot;&gt;Rack middleware&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;align_left&quot;&gt;&lt;tt&gt;.gitignore&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;align_left&quot;&gt;Patterns for files that should be ignored by Git&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;div class=&quot;caption&quot;&gt;&lt;span class=&quot;header&quot;&gt;Table 1.1: &lt;/span&gt; &lt;/div&gt;&lt;/div&gt;

&lt;h4&gt;1.2.4 Bundler&lt;/h4&gt;

&lt;p&gt;在创建了全新的rails应用之后下一步就是运用bundler来安装你所需要的 gem ，你可以用你最喜欢的文本编辑器打开 Gemfile&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ cd first_app/
$ mate Gemfile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你会看到类似的东西：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;http://rubygems.org&amp;#39;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;gem&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;rails&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;3.0.11&amp;#39;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Bundle edge Rails instead:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# gem &amp;#39;rails&amp;#39;, :git =&amp;gt; &amp;#39;git://github.com/rails/rails.git&amp;#39;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;gem&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;sqlite3&amp;#39;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Use unicorn as the web server&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# gem &amp;#39;unicorn&amp;#39;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Deploy with Capistrano&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# gem &amp;#39;capistrano&amp;#39;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# To use debugger&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# gem &amp;#39;ruby-debug&amp;#39;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Bundle the extra gems:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# gem &amp;#39;bj&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# gem &amp;#39;nokogiri&amp;#39;, &amp;#39;1.4.1&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# gem &amp;#39;sqlite3&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# gem &amp;#39;aws-s3&amp;#39;, :require =&amp;gt; &amp;#39;aws/s3&amp;#39;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Bundle gems for certain environments:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# gem &amp;#39;rspec&amp;#39;, :group =&amp;gt; :test&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# group :test do&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#   gem &amp;#39;webrat&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个文件很大一部分内容都被 # 给注释掉了，他们是用bundler语法给出的一些最常用的 gems .现在我们只需要rails这个gem本身和ruby 接口的 SQLite Database. 在 Gemfile 中 我们可以给出明确的 sqlite3 gem.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;source &amp;#39;http://rubygems.org&amp;#39;

gem &amp;#39;rails&amp;#39;, &amp;#39;3.0.11&amp;#39;
gem &amp;#39;sqlite3&amp;#39;, &amp;#39;1.3.3&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们这里把&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gem &amp;#39;sqlite3&amp;#39;, &amp;#39;1.3.3&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;给换成了&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gem &amp;#39;sqlite3&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就指定 Bundler 安装1.3.3版本的sqlite了 （如果你在 OS X Leopard 上运行，那么请注意你还需要一个 1.2.5 版本的 sqlite3-ruby 的 gem：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gem &amp;#39;sqlite3-ruby&amp;#39;, &amp;#39;1.2.5&amp;#39;, :require =&amp;gt; &amp;#39;sqlite3&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个是因为在最新的 gem 中，sqlite的包被改名叫做了 sqlite3 但是在雪豹中可能需要事先编译一下这个包。 ）&lt;/p&gt;

&lt;p&gt;如果你在运行 Ubuntu Linux 你可能还额外的需要安装一下的包&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ sudo apt-get install libxslt-dev libxml2-dev libsqlite3-dev    # Linux only
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦你正确地建立了 Gemfile 安装这些gems 只需要一个命令 bundle install ：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ bundle install
Fetching source index for http://rubygems.org /
.
.
.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里可能会花上几分钟来安装，但是装好了之后我们就可以在上面跑应用程序了。&lt;/p&gt;

&lt;h4&gt;1.2.5 rails server&lt;/h4&gt;

&lt;p&gt;通过 rails new 和 bundle install 我们已经获得了一个可以运行的应用的.怎么运行呢? rails自带了一个命令行程序或者说是 脚本 程序，它能帮我们在本地完成服务器的运行，并且让你可以看到你开发的成果。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ rails server
=&amp;gt; Booting WEBrick
=&amp;gt; Rails 3.0.11 application starting on http://0.0.0.0:3000
=&amp;gt; Call with -d to detach
=&amp;gt; Ctrl-C to shutdown server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这告诉了我们应用程序在IP 0.0.0.0 的端口 3000 已经跑起来了。他会让你的机器开始监听3000端口的所有请求，这时候我们可以通过一个特别的ip地址 127.0.0.1 ，也就是 localhost 来访问这个本地主机。我们在地址栏中输入：(http://localhost:3000/ )&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/riding_rails_3.png&quot; alt=&quot;picture&quot;&gt;&lt;/p&gt;

&lt;p&gt;在这里我们可以直接看到我们应用程序的相关信息，点击 “About your application’s environment” 你会看到&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/riding_rails_3_environment.png&quot; alt=&quot;picture&quot;&gt;&lt;/p&gt;

&lt;p&gt;我们也没必要看这个配置环境太多次，我们将会在下一章移除并替换这个默认页面。&lt;/p&gt;

&lt;h4&gt;1.2.6 模型-视图-控制器（MVC）&lt;/h4&gt;

&lt;p&gt;在开发之前，我觉得先从整体上来认识一下rails的结构比较好。注意rails的默认的应用结构 有一个应用文件夹 app/ 其中包含了几个子目录 model , view , controllers . 这意味着rails遵守着一个模型-视图-控制器 &lt;a href=&quot;http://en.wikipedia.org/wiki/Model-view-controller&quot;&gt;MVC&lt;/a&gt; 设计模式，他将强制性的把管理层（“domain logic” also called “business logic” ）从 展示层（presentation logic）和用户界面（GUI）分离开来。 对于一个网络应用来说，管理层通常包含了例如 用户，文章，产品等等的模型和数据，而 GUI 是对于浏览器来说的一个页面。&lt;/p&gt;

&lt;p&gt;对浏览器来说，要访问一个rails应用，浏览器首先会发送一个请求到rails的controllser上面去，controller会决定具体访问的文件或者模型。有时候controller会直接 抛会一个 view ，一个已经转换成 HTML 语言的一个模板页面。对于一个动态网站来说，更常见的是controller会与model（通常是一个ruby对象，类似用户这样的网站元素）交互，model又会和数据库通信，之后controller将这些数据渲染上视图组合成完整的网页抛回给浏览器。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/mvc_schematic.png&quot; alt=&quot;picture&quot;&gt;&lt;/p&gt;

&lt;p&gt;如果你觉得这东西有点抽象，那么也别担心，我们还会解释 MVC 的 ,后面还有很多关于 MVC 的具体实践。&lt;/p&gt;

&lt;h3&gt;1.3 GIT 版本控制&lt;/h3&gt;

&lt;p&gt;现在我们已经有了一个rails 程序 我们需要在这里完成一个大部分rails 开发者都认可的步骤————这是可选的————把你的程序放置在版本控制之下。版本控制会让你跟踪你的代码的改变，让合作更佳轻松愉快，并且可以轻松的抹去你的错误操作回滚到过去的代码。所以掌握版本控制是一项软件开发人员必须的技能。&lt;/p&gt;

&lt;p&gt;要进行版本控制，又很多选在，但是rails 社区大部分都依赖于 Git ，一个分布式的版本控制工具，是由Linus Torvalds 为了管理 Linux 的内核而开发的。Git 是一个大项目，我们甚至可以为此写出整整一本书来介绍这个软件，我推荐 Scott Chacon 的书 Pro Git (Apress, 2009) .把你的代码都放到Git下面绝对是一个非常不错的选择，你不仅仅可以进行rails项目的开发管理，你还能够与他人共享你的代码并且轻易的将你的项目部署到服务器上面去。&lt;/p&gt;

&lt;h4&gt;1.3.1 安装与配置&lt;/h4&gt;

&lt;p&gt;首先你应该安装git，关于这个步骤这里不再赘述，具体可以看Installing Git section of Pro Git&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一次的系统配置&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git config --global user.name &amp;quot;Your Name&amp;quot;
$ git config --global user.email youremail@example.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我也习惯用 co 这个命令来代替 checkout ,你可以这样&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git config --global alias.co checkout
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;教程都会使用 checkout 命令，对于那些还没有进行 co 绑定配置也没什么关系，反正在真实世界我用的都是 git co 。&lt;/p&gt;

&lt;p&gt;你也可以设置Git 的 commit 命令的默认编辑器，如果你用了图形界面的编辑器例如 TextMate，gVim, 或者 MacVim,你在这里配置一下来让 Git能够在命令行住正确的用编辑器打开。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git config --global core.editor &amp;quot;mate -w&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里请用 &amp;quot;gvim -f&amp;quot; –对于gvim &amp;quot;mvim -f&amp;quot; –对于MacVim 来替换这里的 &amp;quot;mate -w&amp;quot;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码仓库配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在我们要进行系列步骤来创建一个代码操作，以后每次你都可这么做来新建一个代码库。首先定位到我们的 first app 的根目录下面新建一个代码库：
安装完Git之后，你可以进行如下的一次行配置。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git init
Initialized empty Git repository in /Users/mhartl/rails_projects/   first_app/.git/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下一个步骤就是为代码仓库添加上你的项目文件，这个不走可能那么一点复杂，Git会默认得跟踪每一个文件的改变，但是如果有一些文件我们不需要追踪那么多的文件，例如rails会创建一些日志文件来记录应用程序的运作，这些文件变化频繁，没有必要记录，我们也不希望让我们的版本控制中包含进这样的内容。 Git有一个简单的机制来让你忽略到这样的文件：根目录下面包括一个文件叫 .gitgnore ,这个文件记录着Git那些文件需要忽略上传。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;.bundle
db/*.sqlite3
log/*.log
tmp/**/*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就让Git忽略了那些log文件，rails 的暂时文件（ tmp ），还有 SQLite databases。（例如，要忽略那些 log/文件夹中的log文件，我们用 log/*.log ）大部分的这些文件都是变化频繁，自动生成的，把这些文件包括进版本控制并不合适，也会让同样使用这个资源的人产生不必要的冲突。&lt;/p&gt;

&lt;p&gt;.gitignore 文件中的东西目前可以说是足够的了，但是根据你的系统不同你还是可以添加一些其他的文件，例如我们并不希望上传rails的帮助文档和我们的Vim或者Emacs的临时交换文件，对于OS X 系统的用户来说， Mac 自动索引还会加上一个 /DS_Store 目录，你可以用你最喜欢的编辑器来为你的 .gitignore 添加上你加上的设置。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;.bundle
db/*.sqlite3*
log/*.log
*.log
/tmp/
doc/
*.swp
*~
.project
.DS_Store
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.3.2 增加并且确认&lt;/h4&gt;

&lt;p&gt;最后我们将为新的Rails项目增加Git控制并确认提交我们的结果。我们可以这样增加所有的文件（除了我们在 .gitignore ）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git add .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的点 ‘.’ 代表了当前的文件夹。GIT 很聪明，他会递归的添加你文件夹中的每一个文件到临时区域，他将保存每一次我们作出的改变。我们可以用 status 命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git status
    &lt;span class=&quot;c&quot;&gt;# On branch master&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# Initial commit&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# Changes to be committed:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#   (use &amp;quot;git rm --cached &amp;lt;file&amp;gt;...&amp;quot; to unstage)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#       new file:   README&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#       new file:   Rakefile&lt;/span&gt;
    .
    .
    .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果很长，我在这里忽略了后面的内容。&lt;/p&gt;

&lt;p&gt;你可以用 commit 命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git commit -m &lt;span class=&quot;s2&quot;&gt;&amp;quot;Initial commit&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;master &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;root-commit&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; df0a62f&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; Initial commit
    42 files changed, 8461 insertions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;+&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 0 deletions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;-&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    create mode 100644 README
    create mode 100644 Rakefile
    .
    .
    .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-m 标志能够让你添加一个对确认的描述信息，如果你忽略了 -m ，Git会打开你所设定的编辑来让你输入信息。&lt;/p&gt;

&lt;p&gt;注意，Git的 commit 是本地进行的，仅仅记录了你机器上 commit时候的状态。 这里可以和另一个流行的版本控制工具 Subversion 对比一下， Sububversion是必须每次都与服务器端进行对比确认的。而Git把 Sububversion 的 Commit 功能分成了两块，一个在本地记录你的文件变化（用 git commit ） 然后 把改变推送到服务器端 （ git push ）。我们马上会就看到一个 push 的实例的。&lt;/p&gt;

&lt;p&gt;另外，你可以用 log 命令来 查看你的所有 确认信息。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git log
commit df0a62f3f091e53ffa799309b3e32c27b0b38eb4
Author: Michael Hartl &amp;lt;michael@michaelhartl.com&amp;gt;
Date:   Thu Oct 15 11:36:21 2009 -0700

Initial commit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要退出 git log 你可以输入 q 来退出。&lt;/p&gt;

&lt;h4&gt;1.3.3 GIT 给你带来了什么&lt;/h4&gt;

&lt;p&gt;你可能现在都还是没有搞懂版本控制的好处到底是什么，现在我们来举个例子把（我们会在其他章节用到很多的。。。）假设我们现在做了一个意外的改动，例如。。。把我们的 app/controllers/ 文件夹给删除掉了。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ls app/controllers/
    application_controller.rb
    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rm -rf app/controllers/
    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ls app/controllers/
    ls: app/controllers/: No such file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在这里使用 Unix 的 ls 命令列出了 app/controllers/ 文件夹然后我们还用了 rm 命令行删除了它。这里的 -rf 标志意味着“循环强制性”删除，这会循环地强制性删除所有的文件，文件夹，子文件夹并且不回馈任何确认信息。&lt;/p&gt;

&lt;p&gt;现在我们来看看一看他们都做了什么：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git status
&lt;span class=&quot;c&quot;&gt;# On branch master&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Changed but not updated:&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#   (use &amp;quot;git add/rm &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#   (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working  directory)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#       deleted:    app/controllers/application_controller.rb&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
no changes added to commit &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&amp;quot;git add&amp;quot;&lt;/span&gt; and/or &lt;span class=&quot;s2&quot;&gt;&amp;quot;git commit -a&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在这里看到了一些被删除掉的文件，这个改变只存在于 “工作分支” 上；意味着这些还没又被确认提交。这意味着我们还可以通过 checkout 命令还恢复它 （ -f 标志能够让他们强制覆盖掉原有的改变。）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git checkout -f
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git status
&lt;span class=&quot;c&quot;&gt;# On branch master&lt;/span&gt;
nothing to commit &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;working directory clean&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ls app/controllers/
application_controller.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.3.4 GitHub&lt;/h4&gt;

&lt;p&gt;现在我们应该把我们的项目至于 Git 的版本控制之下了，这时候我们就可以把代码推送到 GitHub 去了，这是一个社会化开源平台来让你共享你的Git 仓库。我们把代码仓库放到 GITHub上面去有两个目的：一个是对我们代码 进行备份，另一个是让代码更容易合作开发。这个步骤是可选的，但是成为一个GitHub 用户将会给你打开参加一个开源项目的大门。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/github_first_page.png&quot; alt=&quot;github&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/create_first_repository.png&quot; alt=&quot;git&quot;&gt;&lt;/p&gt;

&lt;p&gt;GitHub 有收费的项目，但是开源保管代码是免费的，你可以免费注册一个 Github帐号（如果你还没有的话，你可能需要跟随这个&lt;a href=&quot;http://help.github.com/key-setup-redirect&quot;&gt;配置教程&lt;/a&gt; 先）。 然后你要建立一个代码仓库，随后你就可以这样推送上你自己的第一个代码仓库了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git remote add origin git@github.com:&amp;lt;username&amp;gt;/first_app.git
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git push origin master
&lt;span class=&quot;sb&quot;&gt;```&lt;/span&gt; bash

这个命令告诉了 Git 你想要添加 GitHub 作为你的 master （主分支）的 origin （起源）然后推送到GitHub上，当然你要在这里把 给替换成你自己的用户名。我这里用了 railstutorial 作为我的用户名。

    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git remote add origin git@github.com:railstutorial/first_app.git

这就是我们上传到Github的成果啦～

!&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;github&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;http://ruby.railstutorial.org/images/figures/github_repository_page.png&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;####1.3.5 分支，编辑，确认，合并&lt;/span&gt;

如果你跟着我做了上一章，你将会发现GitHub自动显示了我们主分支的 README 文件。这是因为，对于我们的rails来说，我们用 rails 命令的时候rails 就会自动帮你创建一个 README 文件。这对别人来说毫无意义，所以首先我们应该先把 README 文件改成能够描诉我们工程的东西，而不是描述rails框架的东西。这里我们将会用上看到Git的分支，合并，编辑，确认提交。

!&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;pic&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;http://ruby.railstutorial.org/images/figures/rails_readme.png&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

**分支**

Git在建立分支上功能强大，它能够快速有效的创建一个代码仓库的备份，我们更改了这个备份文件（分支），父文件也不会受到任何影响。通常来说，我们可以通过 checkout 加上 -b的标签命令来新建一个分支：

    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git checkout -b modify-README
    Switched to a new branch &lt;span class=&quot;s1&quot;&gt;&amp;#39;modify-README&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git branch
    master
    * modify-README

分支的最大用处就是可以方便的管理多开发者的项目，不过对于单个开发者来说分支很有用。分支能和主分支完全隔离所以，我们如果突然不想要一个分支的时候我们可以直接 check out 到 master 上然后删除分支。

另外，对于教程中这么小的改动我通常不会特地建立一个分支，但是早点学习并实践一个新东西总不是坏事。

**编辑**

在建立了一个分支之后我们改修改一下我们的项目描诉文件了。在这里我建议使用 Markdown 标记语法 ,当你使用 .markdown 后缀的时候GitHub会自动识别出来并且转换成正确的格式。

首先我们要先用 Git版本的 Unix mv命令来更改文件名，然后我们在文件中输入我们需要的内容。

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git mv README README.markdown
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mate README.markdown

这个是新的 README.markdown 文件

    This is the first application &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;
    &lt;span class=&quot;se&quot;&gt;\[&lt;/span&gt;*Ruby on Rails Tutorial: Learn Rails by Example*&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;http://railstutorial.org/&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    by &lt;span class=&quot;se&quot;&gt;\[&lt;/span&gt;Michael Hartl&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;http://michaelhartl.com/&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.

**确定&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;commit&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;**

现在我们先来看看我们分支的状态

    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git status
    &lt;span class=&quot;c&quot;&gt;# On branch modify-README&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# Changes to be committed:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#       renamed:    README -&amp;gt; README.markdown&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# Changed but not updated:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#   (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#       modified:   README.markdown&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;

在此时我们可一使用 git -a 命令来建立快照，但是Git提供了一个便捷的 -a标签用来合并快照和确定的两个动作。（很常用的哟～）

    &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git commit -a -m &lt;span class=&quot;s2&quot;&gt;&amp;quot;Improved the README file&amp;quot;&lt;/span&gt;
    2 files changed, 5 insertions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;+&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 243 deletions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;-&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    delete mode 100644 README
    create mode 100644 README.markdown

注意到我们这里使用了 -a 标志，如果你确认之后又加入了新文件，你还是必须先用 git add 来告诉Git。

**合并**

作出了改变之后我想我们可以这样来把我们的文件从分支合并进来了：

&lt;span class=&quot;sb&quot;&gt;```&lt;/span&gt; bash
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git checkout master
Switched to branch &lt;span class=&quot;s1&quot;&gt;&amp;#39;master&amp;#39;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git merge modify-README
Updating 34f06b7..2c92bef
Fast forward
README          |  243      -------------------------------------------------------
README.markdown |    5 +
2 files changed, 5 insertions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;+&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 243 deletions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;-&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
delete mode 100644 README
create mode 100644 README.markdown
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意到Git的输出文件常常包括像 34f06b7 这样的东西，这个和Git的仓库表示方法有关系，你修改细节会在这里显示出来。&lt;/p&gt;

&lt;p&gt;在你合并了修改之后你就可以用 git branch -d 命令来删除这个分支了。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git branch -d modify-README
Deleted branch modify-README (was 2c92bef).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个步骤完全是可选的，事实上，当你合并了一个分支之后常常就是一个分支的结点了，所以合并过后直接删除分支是很常见的事情。&lt;/p&gt;

&lt;p&gt;另外提一句，Git 中你可以这么做来放弃一整个分支 ，你可以用 git branch -D 命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# For illustration only; don&amp;#39;t do this unless you mess up a branch&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git checkout -b topic-branch
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&amp;lt;really screw up the branch&amp;gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git add .
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git commit -a -m &lt;span class=&quot;s2&quot;&gt;&amp;quot;Screwed up&amp;quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git checkout master
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git branch -D topic-branch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;推送&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在我们已经更新了我们的 README 文件了，现在该来把我们的新东西推送到GitHub上了。因为我们在之前已经做过了一次推送，所以这次我们可以忽略 origin master 而直接运行 git push：&lt;/p&gt;

&lt;p&gt;$ git push&lt;/p&gt;

&lt;p&gt;在某些系统上面可能会出现这样的问题：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git push
fatal: The current branch master is not tracking anything.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种时候你可能还是应该运行 git push origin master 来完成提交。在这里我们可以看到 Github已经完成了对Markdown语法的识别并且显示在了你的仓库首页上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/new_readme.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;h3&gt;1.4 部署&lt;/h3&gt;

&lt;p&gt;现在我们就可以把我们的rails程序部署到网络上去了（虽然还几乎是空的）。这个步骤也是可选的，但是早早部署运行上你的代码能让你的开发周期缩短，并且更快发现你在开发上面的问题。当然你也可以选择在你把整个程序都编写完成之后再部署————只是那样很容易出现各种让你崩溃的问题。&lt;/p&gt;

&lt;p&gt;部署Rails 应用原本是一个不太容易的事情，但是随着技术快速发展，rails云服务的出现，现在已经有了一些很成熟的选择。有：共享主机或者VPN运行&lt;a href=&quot;http://www.modrails.com/&quot;&gt;Phusion Passenger&lt;/a&gt; （一个模块化 apache 和 Nginx 的部署解决方案），一条龙服务的服务商例如 &lt;a href=&quot;http://engineyard.com/&quot;&gt;Engine Yard 和 Rails Machine&lt;/a&gt; ，还有云端服务器 &lt;a href=&quot;http://cloud.engineyard.com/&quot;&gt;Engine Yard Cloud&lt;/a&gt; 和 &lt;a href=&quot;http://heroku.com/&quot;&gt;Heroku&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;在这里我的选择是 Heroku ，它是专为ruby on rails 打造的一个云端平台，它让部署rails应用变的无比的简单，只要你的代码是用 Git 版本控制的，下面我们就来把我们的应用部署到Heroku上去。&lt;/p&gt;

&lt;h4&gt;1.4.1 安装 Heroku&lt;/h4&gt;

&lt;p&gt;在注册了一个 Heroku帐号之后我们可以这样来安装 Heroku：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ gem install heroku
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后用 heroku 命令来为我们的例程建立一个Heroku云端服务器。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ heroku create
Created http://severe-fire-61.heroku.com/ | git@heroku.com:severe-fire-61.git
Git remote heroku added
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里 heroku 命令为你已经建立了一个二级域名，当然现在还什么都没有，但是我们马上就可以把东西部署上去。&lt;/p&gt;

&lt;h4&gt;1.4.2 Heroeroku部署，步骤一&lt;/h4&gt;

&lt;p&gt;要想部署Heroku第一步用 Git 工具推送到 heroku 的云端服务器上去。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ git push heroku master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（此时有些读者可能会遇到这样的报错：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;rake aborted! no such file to load -- sqlite3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个命令大部分时候都可以很好的运行，但是如果出现了这样的问题你应该修改一下我们的Gemfile，它限制了heroku读取 sqlite3 数据库，如下修改后更新就好了。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;source &amp;#39;http://rubygems.org&amp;#39;
gem &amp;#39;rails&amp;#39;, &amp;#39;3.0.11&amp;#39;
gem &amp;#39;sqlite3&amp;#39;, &amp;#39;1.3.3&amp;#39;, :group =&amp;gt; :development
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;）&lt;/p&gt;

&lt;h4&gt;1.4.3 Heroku部署，步骤二&lt;/h4&gt;

&lt;p&gt;现在是步骤2，成功就在眼前了。在你运行了heroku create 后如果要看你部署上的应用程序，你直接访问刚刚创建的地址就可以了，或者你可以运行 heroku open命令来让计算机自动打开一个浏览器来浏览你的网页。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ heroku open
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/heroku_app.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;

&lt;p&gt;一旦成功部署之后 Heroku 就会提供给你一个非常漂亮的用户界面来让你管理自己的应用程序&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ruby.railstutorial.org/images/figures/heroku_info.png&quot; alt=&quot;picc&quot;&gt;&lt;/p&gt;

&lt;h4&gt;1.4.4 Heroku 命令&lt;/h4&gt;

&lt;p&gt;Heroku 有不少命令，我们不会在这本书里用到多少的。现在我之花几分钟来介绍一下如何重命名你的应用：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;$ heroku rename railstutorial
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应为这个名字被我用了，所以你们千万别用这个名字了，。。。你们可以也用heroku自动分配给你们的域名。&lt;/p&gt;

&lt;h3&gt;1.5 结论&lt;/h3&gt;

&lt;p&gt;我们在这一张里面做了很多：安装，开发环境安装，版本控制和部署，如果你想要分享你自己的心不或者提出一些建议，你可以在twitter 或者 facebook 上发类似的消息&lt;/p&gt;

&lt;p&gt;I’m learning Ruby on Rails with @railstutorial! http://railstutorial.org/&lt;/p&gt;

&lt;p&gt;每一句话都可以证明了你实实在在的开始了你的rails学习，下一章我们会学到更深入的东西，LET‘S GET TO IT～&lt;/p&gt;
</description>
                <link>http://tutorial.railschina.org/rails%20%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B/2013/08/28/chapter-1</link>
                <guid>http://tutorial.railschina.org/rails%20%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B/2013/08/28/chapter-1</guid>
                <pubDate>2013-08-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Jekyll Introduction</title>
                <description>&lt;p&gt;This Jekyll introduction will outline specifically  what Jekyll is and why you would want to use it.
Directly following the intro we&amp;#39;ll learn exactly &lt;em&gt;how&lt;/em&gt; Jekyll does what it does.&lt;/p&gt;

&lt;h2&gt;Overview&lt;/h2&gt;

&lt;h3&gt;What is Jekyll?&lt;/h3&gt;

&lt;p&gt;Jekyll is a parsing engine bundled as a ruby gem used to build static websites from
dynamic components such as templates, partials, liquid code, markdown, etc. Jekyll is known as &amp;quot;a simple, blog aware, static site generator&amp;quot;.&lt;/p&gt;

&lt;h3&gt;Examples&lt;/h3&gt;

&lt;p&gt;This website is created with Jekyll. &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Sites&quot;&gt;Other Jekyll websites&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;What does Jekyll Do?&lt;/h3&gt;

&lt;p&gt;Jekyll is a ruby gem you install on your local system.
Once there you can call &lt;code&gt;jekyll --server&lt;/code&gt; on a directory and provided that directory
is setup in a way jekyll expects, it will do magic stuff like parse markdown/textile files, 
compute categories, tags, permalinks, and construct your pages from layout templates and partials.&lt;/p&gt;

&lt;p&gt;Once parsed, Jekyll stores the result in a self-contained static &lt;code&gt;_site&lt;/code&gt; folder.
The intention here is that you can serve all contents in this folder statically from a plain static web-server.&lt;/p&gt;

&lt;p&gt;You can think of Jekyll as a normalish dynamic blog but rather than parsing content, templates, and tags
on each request, Jekyll does this once &lt;em&gt;beforehand&lt;/em&gt; and caches the &lt;em&gt;entire website&lt;/em&gt; in a folder for serving statically.&lt;/p&gt;

&lt;h3&gt;Jekyll is Not Blogging Software&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Jekyll is a parsing engine.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jekyll does not come with any content nor does it have any templates or design elements.
This is a common source of confusion when getting started.
Jekyll does not come with anything you actually use or see on your website - you have to make it.&lt;/p&gt;

&lt;h3&gt;Why Should I Care?&lt;/h3&gt;

&lt;p&gt;Jekyll is very minimalistic and very efficient.
The most important thing to realize about Jekyll is that it creates a static representation of your website requiring only a static web-server.
Traditional dynamic blogs like Wordpress require a database and server-side code.
Heavily trafficked dynamic blogs must employ a caching layer that ultimately performs the same job Jekyll sets out to do; serve static content.&lt;/p&gt;

&lt;p&gt;Therefore if you like to keep things simple and you prefer the command-line over an admin panel UI then give Jekyll a try.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Developers like Jekyll because we can write content like we write code:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ability to write content in markdown or textile in your favorite text-editor.&lt;/li&gt;
&lt;li&gt;Ability to write and preview your content via localhost.&lt;/li&gt;
&lt;li&gt;No internet connection required.&lt;/li&gt;
&lt;li&gt;Ability to publish via git.&lt;/li&gt;
&lt;li&gt;Ability to host your blog on a static web-server.&lt;/li&gt;
&lt;li&gt;Ability to host freely on GitHub Pages.&lt;/li&gt;
&lt;li&gt;No database required.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;How Jekyll Works&lt;/h1&gt;

&lt;p&gt;The following is a complete but concise outline of exactly how Jekyll works.&lt;/p&gt;

&lt;p&gt;Be aware that core concepts are introduced in rapid succession without code examples.
This information is not intended to specifically teach you how to do anything, rather it
is intended to give you the &lt;em&gt;full picture&lt;/em&gt; relative to what is going on in Jekyll-world.&lt;/p&gt;

&lt;p&gt;Learning these core concepts should help you avoid common frustrations and ultimately 
help you better understand the code examples contained throughout Jekyll-Bootstrap.&lt;/p&gt;

&lt;h2&gt;Initial Setup&lt;/h2&gt;

&lt;p&gt;After &lt;a href=&quot;/index.html#start-now&quot;&gt;installing jekyll&lt;/a&gt; you&amp;#39;ll need to format your website directory in a way jekyll expects.
Jekyll-bootstrap conveniently provides the base directory format.&lt;/p&gt;

&lt;h3&gt;The Jekyll Application Base Format&lt;/h3&gt;

&lt;p&gt;Jekyll expects your website directory to be laid out like so:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   |-- post.html
|-- _posts
|   |-- 2011-10-25-open-source-is-good.markdown
|   |-- 2011-04-26-hello-world.markdown
|-- _site
|-- index.html
|-- assets
    |-- css
        |-- style.css
    |-- javascripts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;&lt;br&gt;
Stores configuration data.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_includes&lt;/strong&gt;&lt;br&gt;
This folder is for partial views.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_layouts&lt;/strong&gt;&lt;br&gt;
This folder is for the main templates your content will be inserted into.
You can have different layouts for different pages or page sections.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_posts&lt;/strong&gt;&lt;br&gt;
This folder contains your dynamic content/posts.
the naming format is required to be &lt;code&gt;@YEAR-MONTH-DATE-title.MARKUP@&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_site&lt;/strong&gt;&lt;br&gt;
This is where the generated site will be placed once Jekyll is done transforming it. &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;assets&lt;/strong&gt;&lt;br&gt;
This folder is not part of the standard jekyll structure.
The assets folder represents &lt;em&gt;any generic&lt;/em&gt; folder you happen to create in your root directory.
Directories and files not properly formatted for jekyll will be left untouched for you to serve normally.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(read more: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Usage&quot;&gt;https://github.com/mojombo/jekyll/wiki/Usage&lt;/a&gt;)&lt;/p&gt;

&lt;h3&gt;Jekyll Configuration&lt;/h3&gt;

&lt;p&gt;Jekyll supports various configuration options that are fully outlined here:
&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Configuration&quot;&gt;https://github.com/mojombo/jekyll/wiki/Configuration&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Content in Jekyll&lt;/h2&gt;

&lt;p&gt;Content in Jekyll is either a post or a page.
These content &amp;quot;objects&amp;quot; get inserted into one or more templates to build the final output for its respective static-page.&lt;/p&gt;

&lt;h3&gt;Posts and Pages&lt;/h3&gt;

&lt;p&gt;Both posts and pages should be written in markdown, textile, or HTML and may also contain Liquid templating syntax.
Both posts and pages can have meta-data assigned on a per-page basis such as title, url path, as well as arbitrary custom meta-data.&lt;/p&gt;

&lt;h3&gt;Working With Posts&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Post&lt;/strong&gt;&lt;br&gt;
Posts are created by properly formatting a file and placing it the &lt;code&gt;_posts&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br&gt;
A post must have a valid filename in the form &lt;code&gt;YEAR-MONTH-DATE-title.MARKUP&lt;/code&gt; and be placed in the &lt;code&gt;_posts&lt;/code&gt; directory. 
If the data format is invalid Jekyll will not recognize the file as a post. The date and title are automatically parsed from the filename of the post file.
Additionally, each file must have &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt; prepended to its content.
YAML Front-Matter is a valid YAML syntax specifying meta-data for the given file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order&lt;/strong&gt;&lt;br&gt;
Ordering is an important part of Jekyll but it is hard to specify a custom ordering strategy.
Only reverse chronological and chronological ordering is supported in Jekyll.&lt;/p&gt;

&lt;p&gt;Since the date is hard-coded into the filename format, to change the order, you must change the dates in the filenames.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tags&lt;/strong&gt;&lt;br&gt;
Posts can have tags associated with them as part of their meta-data.
Tags may be placed on posts by providing them in the post&amp;#39;s YAML front matter.
You have access to the post-specific tags in the templates. These tags also get added to the sitewide collection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories&lt;/strong&gt;&lt;br&gt;
Posts may be categorized by providing one or more categories in the YAML front matter.
Categories offer more significance over tags in that they can be reflected in the URL path to the given post.
Note categories in Jekyll work in a specific way.
If you define more than one category you are defining a category hierarchy &amp;quot;set&amp;quot;.
Example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;---
title :  Hello World
categories : [lessons, beginner]
---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This defines the category hierarchy &amp;quot;lessons/beginner&amp;quot;. Note this is &lt;em&gt;one category&lt;/em&gt; node in Jekyll.
You won&amp;#39;t find &amp;quot;lessons&amp;quot; and &amp;quot;beginner&amp;quot; as two separate categories unless you define them elsewhere as singular categories.&lt;/p&gt;

&lt;h3&gt;Working With Pages&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Page&lt;/strong&gt;&lt;br&gt;
Pages are created by properly formatting a file and placing it anywhere in the root directory or subdirectories that do &lt;em&gt;not&lt;/em&gt; start with an underscore.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br&gt;
In order to register as a Jekyll page the file must contain &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt;.
Registering a page means 1) that Jekyll will process the page and 2) that the page object will be available in the &lt;code&gt;site.pages&lt;/code&gt; array for inclusion into your templates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories and Tags&lt;/strong&gt;&lt;br&gt;
Pages do not compute categories nor tags so defining them will have no effect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sub-Directories&lt;/strong&gt;&lt;br&gt;
If pages are defined in sub-directories, the path to the page will be reflected in the url.
Example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;.
|-- people
    |-- bob
        |-- essay.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This page will be available at &lt;code&gt;http://yourdomain.com/people/bob/essay.html&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recommended Pages&lt;/strong&gt;  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;br&gt;
You will always want to define the root index.html page as this will display on your root URL.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;404.html&lt;/strong&gt;&lt;br&gt;
Create a root 404.html page and GitHub Pages will serve it as your 404 response.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sitemap.html&lt;/strong&gt;&lt;br&gt;
Generating a sitemap is good practice for SEO.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;about.html&lt;/strong&gt;&lt;br&gt;
A nice about page is easy to do and gives the human perspective to your website.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Templates in Jekyll&lt;/h2&gt;

&lt;p&gt;Templates are used to contain a page&amp;#39;s or post&amp;#39;s content.
All templates have access to a global site object variable: &lt;code&gt;site&lt;/code&gt; as well as a page object variable: &lt;code&gt;page&lt;/code&gt;.
The site variable holds all accessible content and metadata relative to the site.
The page variable holds accessible data for the given page or post being rendered at that point.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Create a Template&lt;/strong&gt;&lt;br&gt;
Templates are created by properly formatting a file and placing it in the &lt;code&gt;_layouts&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br&gt;
Templates should be coded in HTML and contain YAML Front Matter. 
All templates can contain Liquid code to work with your site&amp;#39;s data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rending Page/Post Content in a Template&lt;/strong&gt;&lt;br&gt;
There is a special variable in all templates named : &lt;code&gt;content&lt;/code&gt;.
The &lt;code&gt;content&lt;/code&gt; variable holds the page/post content including any sub-template content previously defined.
Render the content variable wherever you want your main content to be injected into your template:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code&gt;...
&amp;lt;body&amp;gt;
  &amp;lt;div id=&amp;quot;sidebar&amp;quot;&amp;gt; ... &amp;lt;/div&amp;gt;
  &amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;
    &amp;#123;{content}&amp;#125;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
...&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;Sub-Templates&lt;/h3&gt;

&lt;p&gt;Sub-templates are exactly templates with the only difference being they 
define another &amp;quot;root&amp;quot; layout/template within their YAML Front Matter.
This essentially means a template will render inside of another template.&lt;/p&gt;

&lt;h3&gt;Includes&lt;/h3&gt;

&lt;p&gt;In Jekyll you can define include files by placing them in the &lt;code&gt;_includes&lt;/code&gt; folder.
Includes are NOT templates, rather they are just code snippets that get included into templates.
In this way, you can treat the code inside includes as if it was native to the parent template.&lt;/p&gt;

&lt;p&gt;Any valid template code may be used in includes.&lt;/p&gt;

&lt;h2&gt;Using Liquid for Templating&lt;/h2&gt;

&lt;p&gt;Templating is perhaps the most confusing and frustrating part of Jekyll.
This is mainly due to the fact that Jekyll templates must use the Liquid Templating Language.&lt;/p&gt;

&lt;h3&gt;What is Liquid?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Shopify/liquid&quot;&gt;Liquid&lt;/a&gt; is a secure templating language developed by &lt;a href=&quot;http://shopify.com&quot;&gt;Shopify&lt;/a&gt;.
Liquid is designed for end-users to be able to execute logic within template files 
without imposing any security risk on the hosting server.&lt;/p&gt;

&lt;p&gt;Jekyll uses Liquid to generate the post content within the final page layout structure and as the primary interface for working with
your site and post/page data. &lt;/p&gt;

&lt;h3&gt;Why Do We Have to Use Liquid?&lt;/h3&gt;

&lt;p&gt;GitHub uses Jekyll to power &lt;a href=&quot;http://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;. 
GitHub cannot afford to run arbitrary code on their servers so they lock developers down via Liquid.&lt;/p&gt;

&lt;h3&gt;Liquid is Not Programmer-Friendly.&lt;/h3&gt;

&lt;p&gt;The short story is liquid is not real code and its not intended to execute real code.
The point being you can&amp;#39;t do jackshit in liquid that hasn&amp;#39;t been allowed explicitly by the implementation.
What&amp;#39;s more you can only access data-structures that have been explicitly passed to the template. &lt;/p&gt;

&lt;p&gt;In Jekyll&amp;#39;s case it is not possible to alter what is passed to Liquid without hacking the gem or running custom plugins. 
Both of which cannot be supported by GitHub Pages.&lt;/p&gt;

&lt;p&gt;As a programmer - this is very frustrating.&lt;/p&gt;

&lt;p&gt;But rather than look a gift horse in the mouth we are going to 
suck it up and view it as an opportunity to work around limitations and adopt client-side solutions when possible.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;br&gt;
My personal stance is to not invest time trying to hack liquid. It&amp;#39;s really unnecessary
&lt;em&gt;from a programmer&amp;#39;s&lt;/em&gt; perspective. That is to say if you have the ability to run custom plugins (i.e. run arbitrary ruby code)
you are better off sticking with ruby. Toward that end I&amp;#39;ve built &lt;a href=&quot;http://github.com/plusjade/mustache-with-jekyll&quot;&gt;Mustache-with-Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Static Assets&lt;/h2&gt;

&lt;p&gt;Static assets are any file in the root or non-underscored subfolders that are not pages.
That is they have no valid YAML Front Matter and are thus not treated as Jekyll Pages.&lt;/p&gt;

&lt;p&gt;Static assets should be used for images, css, and javascript files. &lt;/p&gt;

&lt;h2&gt;How Jekyll Parses Files&lt;/h2&gt;

&lt;p&gt;Remember Jekyll is a processing engine. There are two main types of parsing in Jekyll.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Content parsing.&lt;/strong&gt;&lt;br&gt;
This is done with textile or markdown.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Template parsing.&lt;/strong&gt;&lt;br&gt;
This is done with the liquid templating language.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And thus there are two main types of file formats needed for this parsing.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Post and Page files.&lt;/strong&gt;&lt;br&gt;
All content in Jekyll is either a post or a page so valid posts and pages are parsed with markdown or textile.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Template files.&lt;/strong&gt;&lt;br&gt;
These files go in &lt;code&gt;_layouts&lt;/code&gt; folder and contain your blogs &lt;strong&gt;templates&lt;/strong&gt;. They should be made in HTML with the help of Liquid syntax.
Since include files are simply injected into templates they are essentially parsed as if they were native to the template.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Arbitrary files and folders.&lt;/strong&gt;&lt;br&gt;
Files that &lt;em&gt;are not&lt;/em&gt; valid pages are treated as static content and pass through 
Jekyll untouched and reside on your blog in the exact structure and format they originally existed in.&lt;/p&gt;

&lt;h3&gt;Formatting Files for Parsing.&lt;/h3&gt;

&lt;p&gt;We&amp;#39;ve outlined the need for valid formatting using &lt;strong&gt;YAML Front Matter&lt;/strong&gt;.
Templates, posts, and pages all need to provide valid YAML Front Matter even if the Matter is empty.
This is the only way Jekyll knows you want the file processed.&lt;/p&gt;

&lt;p&gt;YAML Front Matter must be prepended to the top of template/post/page files:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;---
layout: post
category : pages
tags : [how-to, jekyll]
---

... contents ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Three hyphens on a new line start the Front-Matter block and three hyphens on a new line end the block.
The data inside the block must be valid YAML.&lt;/p&gt;

&lt;p&gt;Configuration parameters for YAML Front-Matter is outlined here:
&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;A comprehensive explanation of YAML Front Matter&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;Defining Layouts for Posts and Templates Parsing.&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;layout&lt;/code&gt; parameter in the YAML Front Matter defines the template file for which the given post or template should be injected into.
If a template file specifies its own layout, it is effectively being used as a &lt;code&gt;sub-template.&lt;/code&gt;
That is to say loading a post file into a template file that refers to another template file with work in the way you&amp;#39;d expect; as a nested sub-template.&lt;/p&gt;

&lt;h2&gt;How Jekyll Generates the Final Static Files.&lt;/h2&gt;

&lt;p&gt;Ultimately, Jekyll&amp;#39;s job is to generate a static representation of your website. 
The following is an outline of how that&amp;#39;s done:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jekyll collects data.&lt;/strong&gt;&lt;br&gt;
Jekyll scans the posts directory and collects all posts files as post objects. It then scans the layout assets and collects those and finally scans other directories in search of pages.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jekyll computes data.&lt;/strong&gt;&lt;br&gt;
Jekyll takes these objects, computes metadata (permalinks, tags, categories, titles, dates) from them and constructs one 
big &lt;code&gt;site&lt;/code&gt; object that holds all the posts, pages, layouts, and respective metadata.
At this stage your site is one big computed ruby object.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jekyll liquifies posts and templates.&lt;/strong&gt;&lt;br&gt;
Next jekyll loops through each post file and converts (through markdown or textile) and &lt;strong&gt;liquifies&lt;/strong&gt; the post inside of its respective layout(s).
Once the post is parsed and liquified inside the the proper layout structure, the layout itself is &amp;quot;liquified&amp;quot;.&lt;br&gt;
&lt;strong&gt;Liquification&lt;/strong&gt; is defined as follows: Jekyll initiates a Liquid template, and passes a simpler hash representation of the ruby site object as well as a simpler
hash representation of the ruby post object. These simplified data structures are what you have access to in the templates.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jekyll generates output.&lt;/strong&gt;&lt;br&gt;
Finally the liquid templates are &amp;quot;rendered&amp;quot;, thereby processing any liquid syntax provided in the templates
and saving the final, static representation of the file.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Notes.&lt;/strong&gt;&lt;br&gt;
Because Jekyll computes the entire site in one fell swoop, each template is given access to 
a global &lt;code&gt;site&lt;/code&gt; hash that contains useful data. It is this data that you&amp;#39;ll iterate through and format 
using the Liquid tags and filters in order to render it onto a given page.&lt;/p&gt;

&lt;p&gt;Remember, in Jekyll you are an end-user. Your API has only two components:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The manner in which you setup your directory.&lt;/li&gt;
&lt;li&gt;The liquid syntax and variables passed into the liquid templates.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All the data objects available to you in the templates via Liquid are outlined in the &lt;strong&gt;API Section&lt;/strong&gt; of Jekyll-Bootstrap.
You can also read the original documentation here: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Template-Data&quot;&gt;https://github.com/mojombo/jekyll/wiki/Template-Data&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope this paints a clearer picture of what Jekyll is doing and why it works the way it does.
As noted, our main programming constraint is the fact that our API is limited to what is accessible via Liquid and Liquid only.&lt;/p&gt;

&lt;p&gt;Jekyll-bootstrap is intended to provide helper methods and strategies aimed at making it more intuitive and easier to work with Jekyll =)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thank you&lt;/strong&gt; for reading this far.&lt;/p&gt;

&lt;h2&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Please take a look at &lt;a href=&quot;&quot;&gt;&lt;/a&gt; 
or jump right into &lt;a href=&quot;&quot;&gt;Usage&lt;/a&gt; if you&amp;#39;d like.&lt;/p&gt;
</description>
                <link>http://tutorial.railschina.org/lessons/2011/12/29/jekyll-introduction</link>
                <guid>http://tutorial.railschina.org/lessons/2011/12/29/jekyll-introduction</guid>
                <pubDate>2011-12-29T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
